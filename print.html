<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Example</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="index.html">Введение</a></li><li><a href="hello.html"><strong aria-hidden="true">1.</strong> Привет, мир!</a></li><li><ol class="section"><li><a href="hello/comment.html"><strong aria-hidden="true">1.1.</strong> Комментарии</a></li><li><a href="hello/print.html"><strong aria-hidden="true">1.2.</strong> Форматированный вывод</a></li><li><ol class="section"><li><a href="hello/print/print_debug.html"><strong aria-hidden="true">1.2.1.</strong> Debug</a></li><li><a href="hello/print/print_display.html"><strong aria-hidden="true">1.2.2.</strong> Display</a></li><li><ol class="section"><li><a href="hello/print/print_display/testcase_list.html"><strong aria-hidden="true">1.2.2.1.</strong> Пример: Список</a></li></ol></li><li><a href="hello/print/fmt.html"><strong aria-hidden="true">1.2.3.</strong> Форматирование</a></li></ol></li></ol></li><li><a href="primitives.html"><strong aria-hidden="true">2.</strong> Примитивы</a></li><li><ol class="section"><li><a href="primitives/literals.html"><strong aria-hidden="true">2.1.</strong> Литералы и операторы</a></li><li><a href="primitives/tuples.html"><strong aria-hidden="true">2.2.</strong> Кортежи</a></li><li><a href="primitives/array.html"><strong aria-hidden="true">2.3.</strong> Массив и срезы</a></li></ol></li><li><a href="custom_types.html"><strong aria-hidden="true">3.</strong> Пользовательские типы</a></li><li><ol class="section"><li><a href="custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> Структуры</a></li><li><a href="custom_types/enum.html"><strong aria-hidden="true">3.2.</strong> Перечисления</a></li><li><ol class="section"><li><a href="custom_types/enum/enum_use.html"><strong aria-hidden="true">3.2.1.</strong> Декларация use</a></li><li><a href="custom_types/enum/c_like.html"><strong aria-hidden="true">3.2.2.</strong> C-подобные перечисления</a></li><li><a href="custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> Пример: Связанный список</a></li></ol></li><li><a href="custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> Константы</a></li></ol></li><li><a href="variable_bindings.html"><strong aria-hidden="true">4.</strong> Связывание переменных</a></li><li><ol class="section"><li><a href="variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> Изменяемость</a></li><li><a href="variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> Область видимости и затенение</a></li><li><a href="variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> Предварительное объявление</a></li></ol></li><li><a href="types.html"><strong aria-hidden="true">5.</strong> Типы</a></li><li><ol class="section"><li><a href="types/cast.html"><strong aria-hidden="true">5.1.</strong> Приведение типов</a></li><li><a href="types/literals.html"><strong aria-hidden="true">5.2.</strong> Литералы</a></li><li><a href="types/inference.html"><strong aria-hidden="true">5.3.</strong> Вывод типов</a></li><li><a href="types/alias.html"><strong aria-hidden="true">5.4.</strong> Псевдонимы</a></li></ol></li><li><a href="conversion.html"><strong aria-hidden="true">6.</strong> Conversion</a></li><li><ol class="section"><li><a href="conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> From и Into</a></li><li><a href="conversion/string.html"><strong aria-hidden="true">6.2.</strong> В и из String</a></li></ol></li><li><a href="expression.html"><strong aria-hidden="true">7.</strong> Выражения</a></li><li><a href="flow_control.html"><strong aria-hidden="true">8.</strong> Управление потоком</a></li><li><ol class="section"><li><a href="flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li><a href="flow_control/loop.html"><strong aria-hidden="true">8.2.</strong> loop</a></li><li><ol class="section"><li><a href="flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> Вложенность и метки</a></li><li><a href="flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> Возврат из циклов</a></li></ol></li><li><a href="flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while</a></li><li><a href="flow_control/for.html"><strong aria-hidden="true">8.4.</strong> for и range</a></li><li><a href="flow_control/match.html"><strong aria-hidden="true">8.5.</strong> match</a></li><li><ol class="section"><li><a href="flow_control/match/destructuring.html"><strong aria-hidden="true">8.5.1.</strong> Деструктуризация</a></li><li><ol class="section"><li><a href="flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">8.5.1.1.</strong> Кортежи</a></li><li><a href="flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">8.5.1.2.</strong> Перечисления</a></li><li><a href="flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">8.5.1.3.</strong> Указатели и ссылки</a></li><li><a href="flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">8.5.1.4.</strong> Структуры</a></li></ol></li><li><a href="flow_control/match/guard.html"><strong aria-hidden="true">8.5.2.</strong> Ограничители шаблонов</a></li><li><a href="flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> Связывание</a></li></ol></li><li><a href="flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li><a href="flow_control/while_let.html"><strong aria-hidden="true">8.7.</strong> while let</a></li></ol></li><li><a href="fn.html"><strong aria-hidden="true">9.</strong> Функции</a></li><li><ol class="section"><li><a href="fn/methods.html"><strong aria-hidden="true">9.1.</strong> Методы</a></li><li><a href="fn/closures.html"><strong aria-hidden="true">9.2.</strong> Замыкания</a></li><li><ol class="section"><li><a href="fn/closures/capture.html"><strong aria-hidden="true">9.2.1.</strong> Захват</a></li><li><a href="fn/closures/input_parameters.html"><strong aria-hidden="true">9.2.2.</strong> Как входные параметры</a></li><li><a href="fn/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> Анонимность типов</a></li><li><a href="fn/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> Входные функции</a></li><li><a href="fn/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> Как выходные параметры</a></li><li><a href="fn/closures/closure_examples.html"><strong aria-hidden="true">9.2.6.</strong> Примеры из стандартной библиотеки</a></li><li><ol class="section"><li><a href="fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li><a href="fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">9.2.6.2.</strong> Iterator::find</a></li></ol></li></ol></li><li><a href="fn/hof.html"><strong aria-hidden="true">9.3.</strong> Функции высшего порядка</a></li><li><a href="fn/diverging.html"><strong aria-hidden="true">9.4.</strong> Расходящиеся функции</a></li></ol></li><li><a href="mod.html"><strong aria-hidden="true">10.</strong> Модули</a></li><li><ol class="section"><li><a href="mod/visibility.html"><strong aria-hidden="true">10.1.</strong> Видимость</a></li><li><a href="mod/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> Видимость структуры</a></li><li><a href="mod/use.html"><strong aria-hidden="true">10.3.</strong> Декларация use</a></li><li><a href="mod/super.html"><strong aria-hidden="true">10.4.</strong> super и self</a></li><li><a href="mod/split.html"><strong aria-hidden="true">10.5.</strong> Иерархия файлов</a></li></ol></li><li><a href="crates.html"><strong aria-hidden="true">11.</strong> Контейнеры</a></li><li><ol class="section"><li><a href="crates/lib.html"><strong aria-hidden="true">11.1.</strong> Библиотеки</a></li><li><a href="crates/link.html"><strong aria-hidden="true">11.2.</strong> extern crate</a></li></ol></li><li><a href="cargo.html"><strong aria-hidden="true">12.</strong> Cargo</a></li><li><ol class="section"><li><a href="cargo/deps.html"><strong aria-hidden="true">12.1.</strong> Зависимости</a></li><li><a href="cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> Соглашения</a></li><li><a href="cargo/test.html"><strong aria-hidden="true">12.3.</strong> Тестирование</a></li></ol></li><li><a href="attribute.html"><strong aria-hidden="true">13.</strong> Атрибуты</a></li><li><ol class="section"><li><a href="attribute/unused.html"><strong aria-hidden="true">13.1.</strong> dead_code (мёртвый код)</a></li><li><a href="attribute/crate.html"><strong aria-hidden="true">13.2.</strong> Контейнеры</a></li><li><a href="attribute/cfg.html"><strong aria-hidden="true">13.3.</strong> cfg (условные атрибуты)</a></li><li><ol class="section"><li><a href="attribute/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> Собственные условия</a></li></ol></li></ol></li><li><a href="generics.html"><strong aria-hidden="true">14.</strong> Обобщения</a></li><li><ol class="section"><li><a href="generics/gen_fn.html"><strong aria-hidden="true">14.1.</strong> Функции</a></li><li><a href="generics/impl.html"><strong aria-hidden="true">14.2.</strong> Реализация</a></li><li><a href="generics/gen_trait.html"><strong aria-hidden="true">14.3.</strong> Типажи</a></li><li><a href="generics/bounds.html"><strong aria-hidden="true">14.4.</strong> Ограничения</a></li><li><ol class="section"><li><a href="generics/bounds/testcase_empty.html"><strong aria-hidden="true">14.4.1.</strong> Пример: пустые ограничения</a></li></ol></li><li><a href="generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> Множественные ограничения</a></li><li><a href="generics/where.html"><strong aria-hidden="true">14.6.</strong> Утверждения where</a></li><li><a href="generics/new_types.html"><strong aria-hidden="true">14.7.</strong> New Type идиома</a></li><li><a href="generics/assoc_items.html"><strong aria-hidden="true">14.8.</strong> Ассоциированные элементы</a></li><li><ol class="section"><li><a href="generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> Проблема</a></li><li><a href="generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> Ассоциированные типы</a></li></ol></li><li><a href="generics/phantom.html"><strong aria-hidden="true">14.9.</strong> PhantomData-параметры</a></li><li><ol class="section"><li><a href="generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> Пример: unit clarification</a></li></ol></li></ol></li><li><a href="scope.html"><strong aria-hidden="true">15.</strong> Правила области видимости</a></li><li><ol class="section"><li><a href="scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li><a href="scope/move.html"><strong aria-hidden="true">15.2.</strong> Владение и перемещение</a></li><li><ol class="section"><li><a href="scope/move/mut.html"><strong aria-hidden="true">15.2.1.</strong> Изменяемость</a></li></ol></li><li><a href="scope/borrow.html"><strong aria-hidden="true">15.3.</strong> Заимствование</a></li><li><ol class="section"><li><a href="scope/borrow/mut.html"><strong aria-hidden="true">15.3.1.</strong> Mutability</a></li><li><a href="scope/borrow/freeze.html"><strong aria-hidden="true">15.3.2.</strong> Замораживание</a></li><li><a href="scope/borrow/alias.html"><strong aria-hidden="true">15.3.3.</strong> Aliasing</a></li><li><a href="scope/borrow/ref.html"><strong aria-hidden="true">15.3.4.</strong> ref паттерн</a></li></ol></li><li><a href="scope/lifetime.html"><strong aria-hidden="true">15.4.</strong> Времена жизни</a></li><li><ol class="section"><li><a href="scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> Явное аннотирование</a></li><li><a href="scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> Функции</a></li><li><a href="scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> Методы</a></li><li><a href="scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> Структуры</a></li><li><a href="scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> Трейты</a></li><li><a href="scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">15.4.6.</strong> Ограничения</a></li><li><a href="scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">15.4.7.</strong> Приведение (coercion)</a></li><li><a href="scope/lifetime/static_lifetime.html"><strong aria-hidden="true">15.4.8.</strong> Static</a></li><li><a href="scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> Сокрытие</a></li></ol></li></ol></li><li><a href="trait.html"><strong aria-hidden="true">16.</strong> Типажи</a></li><li><ol class="section"><li><a href="trait/derive.html"><strong aria-hidden="true">16.1.</strong> Атрибут Derive</a></li><li><a href="trait/ops.html"><strong aria-hidden="true">16.2.</strong> Перегрузка операторов</a></li><li><a href="trait/drop.html"><strong aria-hidden="true">16.3.</strong> Типаж Drop</a></li><li><a href="trait/iter.html"><strong aria-hidden="true">16.4.</strong> Итераторы</a></li><li><a href="trait/clone.html"><strong aria-hidden="true">16.5.</strong> Типаж Clone</a></li></ol></li><li><a href="macros.html"><strong aria-hidden="true">17.</strong> macro_rules!</a></li><li><ol class="section"><li><a href="macros/syntax.html"><strong aria-hidden="true">17.1.</strong> Синтаксис</a></li><li><ol class="section"><li><a href="macros/designators.html"><strong aria-hidden="true">17.1.1.</strong> Указатели</a></li><li><a href="macros/overload.html"><strong aria-hidden="true">17.1.2.</strong> Перегрузка</a></li><li><a href="macros/repeat.html"><strong aria-hidden="true">17.1.3.</strong> Повторение</a></li></ol></li><li><a href="macros/dry.html"><strong aria-hidden="true">17.2.</strong> DRY (Не повторяйся)</a></li><li><a href="macros/dsl.html"><strong aria-hidden="true">17.3.</strong> DSL (Domain Specific Languages)</a></li><li><a href="macros/variadics.html"><strong aria-hidden="true">17.4.</strong> Variadics</a></li></ol></li><li><a href="error.html"><strong aria-hidden="true">18.</strong> Обработка ошибок</a></li><li><ol class="section"><li><a href="error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li><a href="error/option_unwrap.html"><strong aria-hidden="true">18.2.</strong> Option &amp; unwrap</a></li><li><ol class="section"><li><a href="error/option_unwrap/map.html"><strong aria-hidden="true">18.2.1.</strong> Комбинаторы: map</a></li><li><a href="error/option_unwrap/and_then.html"><strong aria-hidden="true">18.2.2.</strong> Комбинаторы: and_then</a></li></ol></li><li><a href="error/result.html"><strong aria-hidden="true">18.3.</strong> Result</a></li><li><ol class="section"><li><a href="error/result/result_map.html"><strong aria-hidden="true">18.3.1.</strong> map для Result</a></li><li><a href="error/result/result_alias.html"><strong aria-hidden="true">18.3.2.</strong> Псевдонимы для Result</a></li><li><a href="error/result/early_returns.html"><strong aria-hidden="true">18.3.3.</strong> Преждевременный выход</a></li><li><a href="error/result/enter_question_mark.html"><strong aria-hidden="true">18.3.4.</strong> Введение ?</a></li></ol></li><li><a href="error/multiple_error_types.html"><strong aria-hidden="true">18.4.</strong> Несколько типов ошибок</a></li><li><ol class="section"><li><a href="error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.4.1.</strong> Получение Result из Option</a></li><li><a href="error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.4.2.</strong> Объявление типа ошибки</a></li><li><a href="error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.4.3.</strong> Упаковка ошибок (Box)</a></li><li><a href="error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.4.4.</strong> Другие способы использования ?</a></li><li><a href="error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">18.4.5.</strong> Оборачивание ошибок</a></li></ol></li><li><a href="error/iter_result.html"><strong aria-hidden="true">18.5.</strong> Итерирование по Result</a></li></ol></li><li><a href="std.html"><strong aria-hidden="true">19.</strong> Типы стандартной библиотеки</a></li><li><ol class="section"><li><a href="std/box.html"><strong aria-hidden="true">19.1.</strong> Box, стек и куча</a></li><li><a href="std/vec.html"><strong aria-hidden="true">19.2.</strong> Вектора</a></li><li><a href="std/str.html"><strong aria-hidden="true">19.3.</strong> Strings</a></li><li><a href="std/option.html"><strong aria-hidden="true">19.4.</strong> Option</a></li><li><a href="std/result.html"><strong aria-hidden="true">19.5.</strong> Result</a></li><li><ol class="section"><li><a href="std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ?</a></li></ol></li><li><a href="std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li><a href="std/hash.html"><strong aria-hidden="true">19.7.</strong> HashMap</a></li><li><ol class="section"><li><a href="std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> Альтернытивные/пользовательские типы ключей</a></li><li><a href="std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> HashSet</a></li></ol></li></ol></li><li><a href="std_misc.html"><strong aria-hidden="true">20.</strong> Разное в стандартной библиотеке</a></li><li><ol class="section"><li><a href="std_misc/threads.html"><strong aria-hidden="true">20.1.</strong> Потоки</a></li><li><ol class="section"><li><a href="std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">20.1.1.</strong> Пример: map-reduce</a></li></ol></li><li><a href="std_misc/channels.html"><strong aria-hidden="true">20.2.</strong> Каналы</a></li><li><a href="std_misc/path.html"><strong aria-hidden="true">20.3.</strong> Path</a></li><li><a href="std_misc/file.html"><strong aria-hidden="true">20.4.</strong> Файловый ввод-вывод</a></li><li><ol class="section"><li><a href="std_misc/file/open.html"><strong aria-hidden="true">20.4.1.</strong> open</a></li><li><a href="std_misc/file/create.html"><strong aria-hidden="true">20.4.2.</strong> create</a></li><li><a href="std_misc/file/read_lines.html"><strong aria-hidden="true">20.4.3.</strong> read lines</a></li></ol></li><li><a href="std_misc/process.html"><strong aria-hidden="true">20.5.</strong> Дочерние процессы</a></li><li><ol class="section"><li><a href="std_misc/process/pipe.html"><strong aria-hidden="true">20.5.1.</strong> Pipes</a></li><li><a href="std_misc/process/wait.html"><strong aria-hidden="true">20.5.2.</strong> Ожидание</a></li></ol></li><li><a href="std_misc/fs.html"><strong aria-hidden="true">20.6.</strong> Работа с файловой системой</a></li><li><a href="std_misc/arg.html"><strong aria-hidden="true">20.7.</strong> Аргументы программы</a></li><li><ol class="section"><li><a href="std_misc/arg/matching.html"><strong aria-hidden="true">20.7.1.</strong> Парсинг аргументов</a></li></ol></li><li><a href="std_misc/ffi.html"><strong aria-hidden="true">20.8.</strong> Foreign Function Interface</a></li></ol></li><li><a href="testing.html"><strong aria-hidden="true">21.</strong> Тестирование</a></li><li><ol class="section"><li><a href="testing/unit_testing.html"><strong aria-hidden="true">21.1.</strong> Unit-тестирование</a></li><li><a href="testing/doc_testing.html"><strong aria-hidden="true">21.2.</strong> Тестирование документации</a></li><li><a href="testing/integration_testing.html"><strong aria-hidden="true">21.3.</strong> Интеграционное тестирование</a></li><li><a href="testing/dev_dependencies.html"><strong aria-hidden="true">21.4.</strong> dev-dependencies</a></li></ol></li><li><a href="unsafe.html"><strong aria-hidden="true">22.</strong> Unsafe операции</a></li><li><a href="compatibility.html"><strong aria-hidden="true">23.</strong> Совместимость</a></li><li><ol class="section"><li><a href="compatibility/raw_identifiers.html"><strong aria-hidden="true">23.1.</strong> Сырые идентификаторы</a></li></ol></li><li><a href="meta.html"><strong aria-hidden="true">24.</strong> Meta</a></li><li><ol class="section"><li><a href="meta/doc.html"><strong aria-hidden="true">24.1.</strong> Документация</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust By Example</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust-на-примерах" id="rust-на-примерах">Rust на примерах</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> - современный язык программирования, нацеленный на безопасность,
скорость и параллелизм. Данные цели выполняются при условии безопасной работы с памятью
без использования сборщика мусора.</p>
<p>Rust на примерах - это набор исполняемых примеров, которые иллюстрируют различные
концепции языка Rust, а так же возможности его стандартной библиотеки.
Для того, чтобы подчеркнуть ещё больше из этих примеров,
не забудьте <a href="https://www.rust-lang.org/tools/install">установить Rust на своём компьютере</a> и
проверить <a href="https://doc.rust-lang.org/std/">официальную документацию</a>. Если вы ранее не сталкивались с языком программирования Rust,
то советую вам для начала ознакомиться с <a href="http://rustbook.ru/">русскоязычной книгой по Rust</a>. Кроме этого можно посмотреть <a href="https://github.com/ruRust/rust-by-example-ru">исходный код этого сайта</a>
или <a href="https://github.com/rust-lang/rust-by-example">оригинала</a>.</p>
<p>Итак, давайте начнём!</p>
<ul>
<li>
<p><a href="hello.html">Hello World</a> - Начните с традиционной программы Hello World.</p>
</li>
<li>
<p><a href="primitives.html">Примитивы</a> - Узнайте о целых числах со знаком, целых числах без знака и других примитивах.</p>
</li>
<li>
<p><a href="custom_types.html">Пользовательские типы</a> - <code>struct</code> и <code>enum</code>.</p>
</li>
<li>
<p><a href="variable_bindings.html">Связывание переменных</a> - изменяемые связывания, область видимости, затенение.</p>
</li>
<li>
<p><a href="types.html">Типы</a> - Узнаете об изменении и определении типов.</p>
</li>
<li>
<p><a href="conversion.html">Преобразования.</a></p>
</li>
<li>
<p><a href="expression.html">Выражения.</a></p>
</li>
<li>
<p><a href="flow_control.html">Управление потоком</a> - <code>if</code>/<code>else</code>, <code>for</code>, и другие.</p>
</li>
<li>
<p><a href="fn.html">Функции</a> - Узнайте о методах, замыканиях и функциях высокого порядка.</p>
</li>
<li>
<p><a href="mod.html">Модули</a> - Организация кода с помощью модулей</p>
</li>
<li>
<p><a href="crates.html">Контейнеры</a> - Пакет - это единица компиляции в Rust. Научитесь создавать библиотеку.</p>
</li>
<li>
<p><a href="cargo.html">Cargo</a> - Познакомтесь с основными функциями официального пакетного менеджера Rust.</p>
</li>
<li>
<p><a href="attribute.html">Атрибуты</a> - Атрибут - это метаданные, применяемые к какому-либо модулю, пакету или элементу.</p>
</li>
<li>
<p><a href="generics.html">Обобщения</a> - Узнайте о написании функции или типа данных, которые могут работать для нескольких типов аргументов.</p>
</li>
<li>
<p><a href="scope.html">Правила областей видимости</a> - Области видимости играют важную роль во владении, заимствовании и продолжительности жизни.</p>
</li>
<li>
<p><a href="trait.html">Traits</a> - Типаж - это набор методов, определенных для неизвестного типа: <code>Self</code>.</p>
</li>
<li>
<p><a href="macros.html">Макросы.</a></p>
</li>
<li>
<p><a href="error.html">Обработка ошибок</a> - Узнаете как в Rust обрабатывать ошибки.</p>
</li>
<li>
<p><a href="std.html">Типы стандартной библиотеки</a> - Узнайте о некоторых пользовательских типах, предоставляемых библиотекой <code>std</code>.</p>
</li>
<li>
<p><a href="std_misc.html">Разное в стандартной библиотеке</a> - Больше пользовательских типов для обработки файлов, потоков.</p>
</li>
<li>
<p><a href="testing.html">Testing</a> - Все виды тестов в Rust.</p>
</li>
<li>
<p><a href="unsafe.html">Unsafe.</a></p>
</li>
<li>
<p><a href="compatibility.html">Совместимость.</a></p>
</li>
<li>
<p><a href="meta.html">Meta</a> - Документация, бенчмаркинг.</p>
</li>
</ul>
<h1><a class="header" href="#Привет-мир" id="Привет-мир">Привет мир</a></h1>
<p>Это исходный код традиционной программы &quot;Привет, мир!&quot;.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Эта строка является комментарием и она будет проигнорирована компилятором
// Протестировать код можно нажав на кнопку &quot;Run&quot; вот тут -&gt;
// так же можно использовать клавиатуру, нажав сочетание клавиш &quot;Ctrl + Enter&quot;

// Этот код можно редактировать не стесняясь, дерзайте!
// Всегда можно вернуть оригинальный код, нажав на кнопку &quot;Reset&quot; вот тут -&gt;

// Это главная функция. С неё начинается исполнение любой программы
fn main() {
    // Следующий код будет исполнен в момент, когда будет запущен исполняемый файл

    // Напечатаем текст в консоли
    println!(&quot;Привет, мир!&quot;);
}
</code></pre></pre>
<p><code>println!</code> - это <a href="macros.html"><em>макрос</em></a>, который отображает текст в консоли.</p>
<p>Исполняемый файл может быть сгенерирован с помощью компилятора Rust - <code>rustc</code>.</p>
<pre><code class="language-sh">$ rustc hello.rs
</code></pre>
<p><code>rustc</code> создаст исполняемый файл <code>hello</code>, который можно будет запустить.</p>
<pre><code class="language-sh">$ ./hello
Привет, мир!
</code></pre>
<h3><a class="header" href="#Задание" id="Задание">Задание</a></h3>
<p>Нажми кнопку 'Run', чтобы увидеть ожидаемый результат.
Затем, добавь новую строку с другим макросом <code>println!</code>, чтобы вывод был таким:</p>
<pre><code class="language-log">Привет, мир!
Я программирую на языке Rust!
</code></pre>
<h1><a class="header" href="#Комментарии" id="Комментарии">Комментарии</a></h1>
<p>Каждая программа, безусловно, нуждается в комментариях и
Rust предоставляет несколько способов комментирования кода:</p>
<ul>
<li><em>Обычные комментарии</em>, которые игнорируются компилятором:
<ul>
<li><code>// Однострочный комментарий. Который завершается в конце строки.</code></li>
<li><code>/* Блочный комментарий, который продолжается до завершающего символа. */</code></li>
</ul>
</li>
<li><em>Doc комментарии</em>, которые будут сгенерированы в HTML<a href="hello/../meta/doc.html">документацию</a>:
<ul>
<li><code>/// Генерация документации для функции.</code></li>
<li><code>//! Генерация документации для модуля.</code></li>
</ul>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // This is an example of a line comment
    // There are two slashes at the beginning of the line
    // And nothing written inside these will be read by the compiler

    // println!(&quot;Hello, world!&quot;);

    // Run it. See? Now try deleting the two slashes, and run it again.

    /* 
     * This is another type of comment, a block comment. In general,
     * line comments are the recommended comment style. But
     * block comments are extremely useful for temporarily disabling
     * chunks of code. /* Block comments can be /* nested, */ */
     * so it takes only a few keystrokes to comment out everything
     * in this main() function. /*/*/* Try it yourself! */*/*/
     */

    /*
    Note: The previous column of `*` was entirely for style. There's
    no actual need for it.
    */

    // You can manipulate expressions more easily with block comments
    // than with line comments. Try deleting the comment delimiters
    // to change the result:
    let x = 5 + /* 90 + */ 5;
    println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
}

</code></pre></pre>
<h3><a class="header" href="#Смотрите-также" id="Смотрите-также">Смотрите также:</a></h3>
<p><a href="hello/../meta/doc.html">Документирование библиотек</a></p>
<h1><a class="header" href="#Форматированный-вывод" id="Форматированный-вывод">Форматированный вывод</a></h1>
<p>Вывод обрабатывается несколькими <a href="hello/macros.html"><code>макросами</code></a>, которые определены в <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>.
Вот некоторые из них:</p>
<ul>
<li><code>format!</code>: записывает форматированный текст в <a href="hello/std/str.html"><code>String</code></a>.</li>
<li><code>print!</code>: работает аналогично с <code>format!</code>, но текст выводится в консоль (io::stdout).</li>
<li><code>println!</code>: аналогично <code>print!</code>, но в конце добавляется переход на новую строку.</li>
<li><code>eprint!</code>: аналогично <code>format!</code>, но текст выводится в стандартный поток ошибок (io::stderr).</li>
<li><code>eprintln!</code>: аналогично <code>eprint!</code>, но в конце добавляется переход на новую строку.</li>
</ul>
<p>Весь текст обрабатывается аналогичным образом. Плюс данного метода в том, что корректность
форматирования будет проверена на этапе компиляции программы.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // `{}` автоматически будет заменено на
    // аргументы. Они будут преобразованы в строку.
    println!(&quot;{} дней&quot;, 31);

    // Без суффиксов, 31 является i32. Можно изменить тип 31,
    // используя суффикс.

    // Существует множество способов работы с форматированным выводом. Можно указать
    // позицию для каждого аргумента.
    println!(&quot;{0}, это {1}. {1}, это {0}&quot;, &quot;Алиса&quot;, &quot;Боб&quot;);

    // Так же можно именовать аргументы.
    println!(&quot;{subject} {verb} {object}&quot;,
             object=&quot;ленивую собаку&quot;,
             subject=&quot;быстрая коричневая лиса&quot;,
             verb=&quot;прыгает через&quot;);

    println!(&quot;{} из {:b} людей знают, что такое двоичный код, а остальные нет.&quot;, 1, 2);

    // Можно выравнивать текст, сдвигая его на указанную ширину.
    // Данный макрос отобразит в консоли
    // &quot;     1&quot;. 5 пробелов и &quot;1&quot;.
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // Можно добавить к цифрам пару нулей. Данный макрос выведет &quot;000001&quot;.
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

    // Компилятор обязательно проверит, что в макрос передано правильное количество
    // аргументов.
    println!(&quot;Меня зовут {0}, {1} {0}&quot;, &quot;Бонд&quot;);
    // ИСПРАВЬТЕ ^ Добавьте недостающий аргумент: &quot;Джеймс&quot;

    // Создаём структуру, которая хранит в себе `i32`. Назовём её `Structure`.
    #[allow(dead_code)]
    struct Structure(i32);

    // Однако, пользовательские типы данных, например, как эта структура
    // требуют более сложной обработки для вывода. Данный код не будет работать.
    println!(&quot;Эта структура `{}` не хочет выводится на экран...&quot;, Structure(3));
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку.
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> содержит в себе много <a href="hello/trait.html"><code>типажей</code></a>, которые управляют
отображением текста. Базовая форма двух самых важных рассмотрена ниже:</p>
<ul>
<li><code>fmt::Debug</code>: Использует маркер <code>{:?}</code>. Форматирует текст для отладочных целей.</li>
<li><code>fmt::Display</code>: Использует маркер <code>{}</code>. Форматирует текст в более элегантном,
удобном для пользователя стиле.</li>
</ul>
<p>В данном примере используется <code>fmt::Display</code>, потому что стандартная библиотека предоставляет
реализацию для данного типа. Для отображения собственных типов потребуется
больше дополнительных шагов.</p>
<h3><a class="header" href="#Задания" id="Задания">Задания</a></h3>
<ul>
<li>Исправьте две ошибки в коде выше (смотрите <code>ИСПРАВЬТЕ</code>), чтобы код
компилировался без ошибок</li>
<li>Добавьте макрос <code>println!</code>, который выводит: <code>Pi is roughly 3.142</code> c помощью
управления количеством знаков после запятой. Для выполнения данного задания создайте
переменную, которая будет хранить в себе значение числа Пи: <code>let pi = 3.141592</code>.
(Подсказка: вам необходимо ознакомиться с документация по
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, чтобы узнать,
как отобразить только часть знаков после запятой в консоли.)</li>
</ul>
<h3><a class="header" href="#Смотрите-также-1" id="Смотрите-также-1">Смотрите также</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/macros.html"><code>макросы</code></a>, <a href="hello/custom_types/structs.html"><code>структуры</code></a>,
and <a href="hello/trait.html"><code>traits</code></a></p>
<h1><a class="header" href="#debug" id="debug">Debug</a></h1>
<p>Все типы, которые будут использовать <code>типажи (traits)</code> форматирования <code>std::fmt</code> требуют
их реализации для возможности печати. Автоматическая реализация предоставлена только для
типов из <code>стандартной библиотеки (std)</code>. Все остальные типы <em>должны</em> иметь собственную реализацию.</p>
<p>C помощью <code>типажа</code> <code>fmt::Debug</code> это сделать очень просто. <em>Все</em> типы могут
<code>выводить</code> (автоматически создавать) реализацию <code>fmt::Debug</code>.
Сделать подобное с <code>fmt::Display</code> невозможно, он должен быть реализован вручную.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Эта структура не может быть напечатана с помощью `fmt::Display`
// или с помощью `fmt::Debug`
struct UnPrintable(i32);

// Атрибут `derive` автоматически реализует
// необходимые методы, чтобы была возможность
// печатать данную `структуру` с помощью `fmt::Debug`.
#[derive(Debug)]
struct DebugPrintable(i32);
#}</code></pre></pre>
<p>Все типы в <code>стандартной библиотеке (std)</code> могут быть напечатаны с <code>{:?}</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Вывод и реализация `fmt::Debug` для `Structure`.
// `Structure` - это структура, которая содержит в себе один `i32`.
#[derive(Debug)]
struct Structure(i32);

// Добавим структуру `Structure` в структуру `Deep`.
// Реализуем для `Deep` возможность вывода с помощью fmt::Debug`.
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // Вывод с помощью `{:?}` аналогичен `{}`.
    println!(&quot;{:?} месяцев в году.&quot;, 12);
    println!(&quot;{1:?} {0:?} - это имя {actor:?}.&quot;,
             &quot;Слэйтер&quot;,
             &quot;Кристиан&quot;,
             actor=&quot;актёра&quot;);

    // `Structure` теперь можно напечатать!
    println!(&quot;Теперь {:?} будет выведена на экран!&quot;, Structure(3));

    // Проблема с `выводом (derive)`, в том, что у нас не будет контроля
    // над тем, как будет выглядеть результат.
    // Что если мы хотим напечатать просто `7`?
    println!(&quot;А теперь напечатаем {:?}&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p>Так что 'fmt:: Debug' определенно делает это для печати, но жертвует некоторыми
изящество. Rust также обеспечивает &quot;красивую печать &quot; с помощью&quot; {:#?}'.</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Pretty print
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<p>Можно вручную реализовать 'fmt:: Display' для управления отображением.</p>
<h3><a class="header" href="#Смотрите-также-2" id="Смотрите-также-2">Смотрите также</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a>, <a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>,
и <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#display" id="display">Display</a></h1>
<p><code>fmt::Debug</code> выглядит не очень компактно и красиво,
поэтому полезно настраивать внешний вид информации, которая будет напечатана.
Это можно сделать реализовав <code>типаж</code> <a href="https://doc.rust-lang.org/std/fmt/"><code>fmt::Display</code></a> вручную,
который использует маркер <code>{}</code> для печати. Его реализация выглядит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Импортируем (с помощью `use`) модуль `fmt`, чтобы мы могли его использовать.
use std::fmt;

// Определяем структуру, для которой будет реализован `fmt::Display`.
// Это простая кортежная структура c именем `Structure`, которая хранит в себе `i32`.
struct Structure(i32);

// Чтобы была возможность использовать маркер `{}`
// `типаж (trait) fmt::Display` должен быть реализован вручную
// для данного типа.
impl fmt::Display for Structure {
    // Этот типаж требует реализацию метода `fmt` с данной сигнатурой:
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Записываем первый элемент в предоставленный выходной поток: `f`.
        // Возвращаем `fmt::Result`, который показывает выполнилась операция
        // успешно или нет. Обратите внимание на то, что синтаксис `write!`
        // похож на синтаксис `println!`.
        write!(f, &quot;{}&quot;, self.0)
    }
}
#}</code></pre></pre>
<p>Вывод <code>fmt::Display</code> может быть более чистым чем <code>fmt::Debug</code>, но может быть
проблемой для <code>стандартной библиотеки (std)</code>. Как нестандартные типы должны отображаться?
Например, если <code>стандартная библиотека (std)</code> предоставляет единый стиль вывода для
<code>Vec&lt;T&gt;</code>, каким этот вывод должен быть? Любой из этих двух?</p>
<ul>
<li><code>Vec&lt;path&gt;</code>: <code>/:/etc:/home/username:/bin</code> (разделитель <code>:</code>)</li>
<li><code>Vec&lt;number&gt;</code>: <code>1,2,3</code> (разделитель <code>,</code>)</li>
</ul>
<p>Нет, потому что не существует идеального стиля вывода для всех типов, поэтому
<code>стандартная библиотека std</code> не может его предоставить. <code>fmt::Display</code> не реализован для
<code>Vec&lt;T&gt;</code> или для других обобщённых контейнеров. Для этих случаев подойдёт <code>fmt::Debug</code>.</p>
<p>Это не проблема, потому что для любых новых <em>контейнеров</em>, типы которых не обобщённые,
может быть реализован <code>fmt::Display</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // Импортируем `fmt`

// Структура, которая хранит в себе два числа.
// Вывод типажа `Debug` добавлен для сравнения с `Display`.
#[derive(Debug)]
struct MinMax(i64, i64);

// Реализуем `Display` для `MinMax`.
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Используем `self.номер`, чтобы получить доступ к каждому полю структуры.
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// Объявим структуру с именованными полями, для сравнения
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// По аналогии, реализуем `Display` для Point2D
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Обращаться к полям структуры Point2D будет по имени
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;Сравниваем структуры:&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;Большой диапазон - {big} и маленький диапазон {small}&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Сравниваем точки:&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // Ошибка. Типажи `Debug` и `Display` были реализованы, но `{:b}`
    // необходима реализация `fmt::Binary`. Следующий код не сработает.
    // println!(&quot;Как выглядит Point2D в виде двоичного кода: {:b}?&quot;, point);
}
</code></pre></pre>
<p>Итак, <code>fmt::Display</code> был реализован, но <code>fmt::Binary</code> нет, следовательно не может быть
использован. <code>std::fmt</code> имеет много таких <a href="hello/print/trait.html"><code>типажей</code></a> и
каждый из них требует свою реализацию. Это более подробно описано в документации к
<a href="https://doc.rust-lang.org/std/fmt/" data-md-type="link"><code>std::fmt</code></a>.</p>
<h3><a class="header" href="#Задание-1" id="Задание-1">Задание</a></h3>
<p>После того, как запустите код, представленный выше, используйте структуру <code>Point2D</code> как пример и
добавьте новую структуру <code>Complex</code>, чтобы вывод был таким:</p>
<pre><code class="language-txt">Display: 3.3 +7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<h3><a class="header" href="#Смотрите-также-3" id="Смотрите-также-3">Смотрите также</a></h3>
<p><a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/print/../../macros.html">macros</a>, <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/../../trait.html"><code>trait</code></a>, и <a href="hello/print/../../mod/use.html">use</a></p>
<h1><a class="header" href="#Пример-Список" id="Пример-Список">Пример: Список</a></h1>
<p>Реализовать <code>fmt::Display</code> для структуры, в которой каждый элемент должен обрабатываться
последовательно не так то просто.
Проблема в том, что <code>write!</code> каждый раз возвращает <code>fmt::Result</code>.
Для правильного обращения с этим необходимо обрабатывать <em>все</em>
результаты. Для этой цели Rust предоставляет оператор <code>?</code>.</p>
<p>Использование <code>?</code> для <code>write!</code> выглядит следующим образом:</p>
<pre><code class="language-rust ignore">// Попробуй исполнить `write!`, чтобы узнать, вернется ли ошибка. Если ошибка, верни ее.
// Если нет, то продолжи.
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>Кроме того, Вы также можете использовать макрос <code>try!', который работает так же. Это немного более подробно и больше не рекомендуется, но вы все равно можете увидеть его в старом коде на Rust. Использование</code>try!` выглядит так:</p>
<pre><code class="language-rust ignore">try!(write!(f, &quot;{}&quot;, value));
</code></pre>
<p>С помощью оператора <code>?</code> реализация <code>fmt::Display</code> для <code>Vec</code> довольно простая:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // Импортируем модуль `fmt`.

// Определим структуру с именем `List`, которая хранит в себе `Vec`.
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Получаем значение с помощью индекса кортежа
        // и создаём ссылку на `vec`.
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // Пройдёмся по каждому `v` в `vec`.
        // Номер итерации хранится в `count`.
        for (count, v) in vec.iter().enumerate() {
            // Для каждого элемента, кроме первого, добавим запятую
            // до вызова `write!`. Используем оператор `?` или `try!`,
            // чтобы вернуться при наличие ошибок.
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // Закроем открытую скобку и вернём значение `fmt::Result`
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<h3><a class="header" href="#Задание-2" id="Задание-2">Задание</a></h3>
<p>Попробуйте изменить программу так, чтобы индекс элемента так же выводился в консоль.
Новый вывод должен выглядеть примерно вот так:</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<h3><a class="header" href="#Смотрите-также-4" id="Смотрите-также-4">Смотрите также</a></h3>
<p><a href="hello/print/print_display/../../../flow_control/for.html"><code>for</code></a>, <a href="hello/print/print_display/../../../scope/borrow/ref.html"><code>ref</code></a>, <a href="hello/print/print_display/../../../std/result.html"><code>Result</code></a>, <a href="hello/print/print_display/../../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/print_display/../../../std/result/question_mark.html"><code>?</code></a>, и <a href="hello/print/print_display/../../../std/vec.html"><code>vec!</code></a></p>
<h1><a class="header" href="#Форматирование" id="Форматирование">Форматирование</a></h1>
<p>Мы видели, что форматирование задаётся <em>макросом форматирования</em>:</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<p>Одна и та же переменная (<code>foo</code>) может быть отображена по разному в зависимости от
используемого <em>типа аргумента</em>: <code>X</code>, <code>o</code> или <em>неопределённый</em>.</p>
<p>Функционал форматирования реализован благодаря типажу,
и для каждого типа аргумента существует свой.
Наиболее распространённый типаж для форматирования - <code>Display</code>,
который работает без аргументов: <code>{}</code>, например.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // Широта
    lat: f32,
    // Долгота
    lon: f32,
}

impl Display for City {
    // `f` - это буфер, данный метод должен записать в него форматированную строку
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!` похож на `format!`, только он запишет форматированную строку
        // в буфер (первый аргумент функции)
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;Дублин&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Осло&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Ванкувер&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // Поменяйте {:?} на {}, когда добавите реализацию
        // типажа fmt::Display
        println!(&quot;{:?}&quot;, *color)
    }
}
</code></pre></pre>
<p>Вы можете посмотреть <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">полный список типажей форматирования</a> и их типы аргументов
в документации к <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>.</p>
<h3><a class="header" href="#Задание-3" id="Задание-3">Задание</a></h3>
<p>Добавьте реализацию типажа <code>fmt::Display</code> для структуры <code>Color</code>,
чтобы вывод отображался вот так:</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>Пару подсказок, если вы не знаете, что делать:</p>
<ul>
<li>Вам <a href="https://doc.rust-lang.org/std/fmt/#argument-types">возможно потребуется перечислить каждый цвет несколько раз</a>,</li>
<li>Вы можете <a href="https://doc.rust-lang.org/std/fmt/#width">добавить немного нулей</a> с <code>:02</code>.</li>
</ul>
<h3><a class="header" href="#Смотрите-также-5" id="Смотрите-также-5">Смотрите также</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></p>
<h1><a class="header" href="#Примитивы" id="Примитивы">Примитивы</a></h1>
<p>Rust предоставляет доступ к большому количеству <code>примитивов</code>:</p>
<h3><a class="header" href="#Скалярные-типы" id="Скалярные-типы">Скалярные типы</a></h3>
<ul>
<li>знаковые целочисленные: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> и <code>isize</code> (размер указателя)</li>
<li>беззнаковые целочисленные: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> и <code>usize</code> (размер указателя)</li>
<li>вещественные: <code>f32</code>, <code>f64</code></li>
<li><code>char</code> скалярное значение Unicode, например: <code>'a'</code>, <code>'α'</code> и <code>'∞'</code> (4 байта каждый)</li>
<li><code>bool</code>: <code>true</code> или <code>false</code></li>
<li>единичный тип <code>()</code>, значение которого так же <code>()</code></li>
</ul>
<p>Несмотря на то, что значение единичного типа является кортежем, оно не считается
составным типом, потому что не содержит нескольких значений.</p>
<h3><a class="header" href="#Составные-типы" id="Составные-типы">Составные типы</a></h3>
<ul>
<li>массивы, например <code>[1, 2, 3]</code></li>
<li>кортежи, например <code>(1, true)</code></li>
</ul>
<p>Переменные всегда должны быть <em>аннотированы</em>.
Числам можно указать определённый тип с помощью <em>суффикса</em>,
иначе будет присвоен <em>тип по умолчанию</em>.
Целочисленные значения по умолчанию <code>i32</code>, а вещественные <code>f64</code>.
Стоит заметить, что Rust также умеет выводить типы из контекста.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Переменные могут быть аннотированы.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Обычная аннотация
    let an_integer   = 5i32; // Суффиксная аннотация

    // Этим переменным будет присвоен тип по умолчанию.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`
    
    // Тип также может быть выведен из контекста.
    let mut inferred_type = 12; // Тип i64 выводится из другой строки
    inferred_type = 4294967296i64;
    
    // Значение изменяемой переменной может быть изменено.
    let mut mutable = 12; // Mutable `i32`
    mutable = 21;
    
    // Ошибка! Тип переменной изменить нельзя.
    mutable = true;
    
    // Переменные могут быть переопределены с помощью затемнения.
    let mutable = true;
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-6" id="Смотрите-также-6">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/">the <code>std</code> library</a>, <a href="variable_bindings/mut.html"><code>mut</code></a>, <a href="types/inference.html">inference</a>, and <a href="variable_bindings/scope.html">shadowing</a></p>
<h1><a class="header" href="#Литералы-и-операторы" id="Литералы-и-операторы">Литералы и операторы</a></h1>
<p>Целочисленное <code>1</code>, вещественное <code>1.2</code>, символ <code>'a'</code>, строка <code>&quot;abc&quot;</code>, логическое <code>true</code>
и единичный тип <code>()</code> могут быть выражены с помощью литералов.</p>
<p>Целочисленные значения так же могут быть выражены с помощью шестнадцатеричного,
восьмеричного или двоичного обозначения используя соответствующие префиксы: <code>0x</code>, <code>0o</code> или <code>0b</code>.</p>
<p>Для улучшения читаемости числовых литералов можно использовать подчёркивания, например
<code>1_000</code> тоже самое, что и <code>1000</code>, и <code>0.000_001</code> равно <code>0.000001</code>.</p>
<p>Нам необходимо указать компилятору какой тип для литерала мы используем.
Сейчас мы используем суффикс <code>u32</code>, чтобы указать, что литерал - беззнаковое целое
число 32-х бит и суффикс <code>i32</code> - знаковое целое 32-х битное число.</p>
<p>Доступные операторы и их приоритет <a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">в Rust</a> такой же как и в других
<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">C-подобных языках</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Целочисленное сложение
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // Целочисленное вычитание
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // ЗАДАНИЕ ^ Попробуйте изменить `1i32` на `1u32`
    // чтобы убедится насколько важен тип данных

    // Булева логика
    println!(&quot;true И false будет {}&quot;, true &amp;&amp; false);
    println!(&quot;true ИЛИ false будет {}&quot;, true || false);
    println!(&quot;НЕ true будет {}&quot;, !true);

    // Побитовые операции
    println!(&quot;0011 И 0101 будет {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 ИЛИ 0101 будет {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 исключающее ИЛИ 0101 будет {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 будет {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 будет 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // Использование подчёркивания для улучшения читаемости!
    println!(&quot;Один миллион записан как {}&quot;, 1_000_000u32);
}
</code></pre></pre>
<h1><a class="header" href="#Кортежи" id="Кортежи">Кортежи</a></h1>
<p>Кортежи - коллекция, которая хранит в себе переменные разных типов. Кортежи
создаются с помощью круглых скобок <code>()</code>, и каждый кортеж является переменной
с сигнатурой типов <code>(T1, T2, ...)</code>, где <code>T1</code>, <code>T2</code> тип члена кортежа.
Функции могут использовать кортежи для возвращения нескольких значений,
так кортежи могут хранить любое количество значений.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Кортежи могут быть использованы как аргументы функции
// и как возвращаемые значения
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // `let` можно использовать для создания связи между кортежем и переменной
    let (integer, boolean) = pair;

    (boolean, integer)
}

// Это структура используется для задания
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // Кортеж с множеством различных типов данных
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // К значениям переменных внутри кортежа можно обратиться по индексу
    println!(&quot;первое значение длинного кортежа: {}&quot;, long_tuple.0);
    println!(&quot;второе значение длинного кортежа: {}&quot;, long_tuple.1);

    // Кортежи могут содержать в себе кортежи
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // Кортежи можно напечатать
    println!(&quot;кортеж из кортежей: {:?}&quot;, tuple_of_tuples);
    
    // Но длинные Кортежи не могут быть напечатаны
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;слишком длинный кортеж: {:?}&quot;, too_long_tuple);
    // TODO ^ Раскомментируйте выше 2 строки, чтобы увидеть ошибку компилятораr

    let pair = (1, true);
    println!(&quot;pair хранит в себе {:?}&quot;, pair);

    println!(&quot;перевёрнутая pair будет {:?}&quot;, reverse(pair));

    // Для создания кортежа, содержащего один элемент, необходимо написать элемент и
    // поставить запятую внутри круглых скобок.
    println!(&quot;кортеж из одного элемента: {:?}&quot;, (5u32,));
    println!(&quot;просто целочисленное значение: {:?}&quot;, (5u32));

    // Кортежи можно разобрать на части (деструктурировать) для создания связи
    let tuple = (1, &quot;привет&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix);

}
</code></pre></pre>
<h3><a class="header" href="#Задание-4" id="Задание-4">Задание</a></h3>
<ol>
<li>
<p><em>Повторение</em>: Добавьте реализацию типажа <code>fmt::Display</code> для <code>структуры</code>
Matrix в примерах выше,
чтобы, когда вы измените формат вывода с <code>{:?}</code> на <code>{}</code>
на консоль вывелось:</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p>Вы можете вернуться на пример <a href="primitives/hello/print/print_display.html">print display</a>.</p>
</li>
<li>
<p>Добавьте функцию <code>transpose</code>, используя функцию <code>reverse</code>, как пример, которая принимает
матрицу, как аргумент и возвращает матрицу, в которой два элемента поменялись местами.
Например:</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<p>Результат:</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<h1><a class="header" href="#Массивы-и-срезы" id="Массивы-и-срезы">Массивы и срезы</a></h1>
<p><code>Массив</code> - это коллекция объектов одинакового типа <code>T</code>, расположенных в памяти
непосредственно друг за другом. Массивы создаются с помощью квадратных
скобок <code>[]</code>, а их размер должен быть известен во время компиляции и является
частью сигнатуры типа <code>[T; size]</code>.</p>
<p><code>Срезы</code> похожи на массивы, но их размер не известен в момент компиляции программы.
Срезы представляют собой объекты, состоящие из указателя на данные и размер среза.
Размер среза равен размеру <code>usize</code> и зависит от архитектуры процессора, например,
для x86-64 он равен 64 бит. Срезы могут быть использованы для заимствования
части массива и будут иметь сигнатуру типа <code>&amp;[T]</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::mem;

// Эта функция заимствует срез
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;первый элемент среза: {}&quot;, slice[0]);
    println!(&quot;в срезе {} элементов&quot;, slice.len());
}

fn main() {
    // Массив фиксированного размера (указывать сигнатуру типа необязательно)
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // Все элементы могут быть инициализированы одной и той же переменной
    let ys: [i32; 500] = [0; 500];

    // Индекс начинается с 0
    println!(&quot;первый элемент массива: {}&quot;, xs[0]);
    println!(&quot;второй элемент массива: {}&quot;, xs[1]);

    // `len` возвращает длину массива
    println!(&quot;размер массива: {}&quot;, xs.len());

    // Память для массивов выделяется в стеке
    println!(&quot;массив занимает {} байт&quot;, mem::size_of_val(&amp;xs));

    // Массивы могут быть автоматически заимствованы как срез
    println!(&quot;заимствуем весь массив, используя срез&quot;);
    analyze_slice(&amp;xs);

    // Срезы могут указывать на часть массива
    println!(&quot;заимствуем часть массива как срез&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // Выход за границу массива заставит компилятор паниковать.
    // Не надо так.
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<h1><a class="header" href="#Пользовательские-типы" id="Пользовательские-типы">Пользовательские типы</a></h1>
<p>В языке программирования Rust пользовательские типы данных
в основном создаются при помощи двух ключевых слов:</p>
<ul>
<li><code>struct</code>: определение структуры</li>
<li><code>enum</code>: определение перечисления</li>
</ul>
<p>Константы так же могут быть созданы с помощью ключевых слов <code>const</code> и <code>static</code>.</p>
<h1><a class="header" href="#Структуры" id="Структуры">Структуры</a></h1>
<p>Существует три типа структур, которые можно создать с помощью ключевого слова <code>struct</code>:</p>
<ul>
<li>Кортежная структура, которая, в общем, является именованным кортежем.</li>
<li>Классическая <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C структура</a>.</li>
<li>Единичная структура, которая не имеет полей, но может быть полезна для обобщённых типов.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8,
}

// A unit struct
struct Nil;

// A tuple struct
struct Pair(i32, f32);

// A struct with two fields
struct Point {
    x: f32,
    y: f32,
}

// Structs can be reused as fields of another struct
#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn main() {
    // Create struct with field init shorthand
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Print debug struct
    println!(&quot;{:?}&quot;, peter);


    // Instantiate a `Point`
    let point: Point = Point { x: 0.3, y: 0.4 };

    // Access the fields of the point
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // Make a new point by using struct update syntax to use the fields of our other one
    let new_point = Point { x: 0.1, ..point };
    // `new_point.y` will be the same as `point.y` because we used that field from `point`
    println!(&quot;second point: ({}, {})&quot;, new_point.x, new_point.y);

    // Destructure the point using a `let` binding
    let Point { x: my_x, y: my_y } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        p1: Point { x: my_y, y: my_x },
        p2: point,
    };

    // Instantiate a unit struct
    let _nil = Nil;

    // Instantiate a tuple struct
    let pair = Pair(1, 0.1);

    // Access the fields of a tuple struct
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // Destructure a tuple struct
    let Pair(integer, decimal) = pair;

    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<h3><a class="header" href="#Задание-5" id="Задание-5">Задание</a></h3>
<ol>
<li>Добавьте функцию <code>rect_area</code>, которая рассчитывает площадь прямоугольника (попробуйте использовать &quot;деструктуризацию&quot; (разбор на части)).</li>
<li>Добавьте функцию <code>square</code>, которая принимает в качестве аргументов <code>Point</code> и <code>f32</code>, а возвращает <code>Rectangle</code>, левый нижний угол которого соответствует <code>Point</code>, а ширина и высота соответствуют <code>f32</code>.</li>
</ol>
<h3><a class="header" href="#Смотрите-также-7" id="Смотрите-также-7">Смотрите также:</a></h3>
<p><a href="custom_types/../attribute.html"><code>атрибуты</code></a> и <a href="custom_types/../flow_control/match/destructuring.html">деструктуризация</a></p>
<h1><a class="header" href="#Перечисления" id="Перечисления">Перечисления</a></h1>
<p>Ключевое слово <code>enum</code> позволяет создавать тип данных,
который представляет собой один из нескольких возможных вариантов.
Любой вариант, действительный как <code>struct</code>, также действителен как <code>enum</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Create an `enum` to classify a web event. Note how both
// names and type information together specify the variant:
// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.
// Each is different and independent.
enum WebEvent {
    // An `enum` may either be `unit-like`,
    PageLoad,
    PageUnload,
    // like tuple structs,
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    Click { x: i64, y: i64 },
}

// A function which takes a `WebEvent` enum as an argument and
// returns nothing.
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        // Destructure `c` from inside the `enum`.
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed '{}'.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` creates an owned `String` from a string slice.
    let pasted  = WebEvent::Paste(&quot;my text&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}

</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-8" id="Смотрите-также-8">Смотрите также:</a></h3>
<p><a href="custom_types/../flow_control/match.html"><code>match</code></a>, <a href="custom_types/../fn.html"><code>fn</code></a> и <a href="custom_types/../std/str.html"><code>String</code></a></p>
<h1><a class="header" href="#Декларация-use" id="Декларация-use">Декларация use</a></h1>
<p>Декларация <code>use</code> используется, чтобы
убрать необходимость указывать область видимости:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Атрибут, который убирает предупреждения компилятора
// о неиспользуемом коде
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // Используем `use` для каждого из вариантов, чтобы они были доступны
    // без указания области видимости.
    use Status::{Poor, Rich};
    // Автоматически используем `use` для каждого из вариантов в `Work`.
    use Work::*;

    // Эквивалентно `Status::Poor`.
    let status = Poor;
    // Эквивалентно to `Work::Civilian`.
    let work = Civilian;

    match status {
        // Обратите внимание, как используются варианты из перечисления `Status`
        // благодаря `use`
        Rich =&gt; println!(&quot;У богатого куча денег!&quot;),
        Poor =&gt; println!(&quot;У бедняка денег нет, но он держится...&quot;),
    }

    match work {
        // И снова используем варианты напрямую.
        Civilian =&gt; println!(&quot;Гражданин работает!&quot;),
        Soldier  =&gt; println!(&quot;Солдаты служат!&quot;),
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-9" id="Смотрите-также-9">Смотрите также:</a></h3>
<p><a href="custom_types/enum/../../flow_control/match.html"><code>match</code> (сопоставление с образцом)</a> и <a href="custom_types/enum/../../mod/use.html"><code>use</code></a></p>
<h1><a class="header" href="#С-подобные" id="С-подобные">С-подобные</a></h1>
<p><code>enum</code> могут быть использованы как C-подобные перечисления.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Атрибут, который убирает предупреждения компилятора
// о неиспользуемом коде
#![allow(dead_code)]

// enum с неявным дискриминатором (начинается с 0)
enum Number {
    Zero,
    One,
    Two,
}

// enum с явным дискриминатором
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` может быть преобразован в целочисленное значение.
    println!(&quot;нулевой элемент {}&quot;, Number::Zero as i32);
    println!(&quot;первый элемент {}&quot;, Number::One as i32);

    println!(&quot;красный цвет #{:06x}&quot;, Color::Red as i32);
    println!(&quot;голубой цвет #{:06x}&quot;, Color::Blue as i32);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-10" id="Смотрите-также-10">Смотрите также:</a></h3>
<p><a href="custom_types/enum/../../types/cast.html">приведение типа</a></p>
<h1><a class="header" href="#Пример-Связанный-список" id="Пример-Связанный-список">Пример: Связанный список</a></h1>
<p>Пример использования <code>enums</code> для создания связанного списка:</p>
<pre><pre class="playpen"><code class="language-rust editable">use List::*;

enum List {
    // Cons: Кортежная структура, которая хранит элемент
    // и указатель на следующий узел
    Cons(u32, Box&lt;List&gt;),
    // Nil: Узел, обозначающий конец связанного списка
    Nil,
}

// Методы могут быть присоединены к перечислению
impl List {
    // Создаём пустой список
    fn new() -&gt; List {
        // `Nil` имеет тип `List`
        Nil
    }

    // Функция, которая принимает список и возвращает тот же список,
    // но с новым элементом в начале
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` также имеет тип `List`
        Cons(elem, Box::new(self))
    }

    // Возвращаем длину списка
    fn len(&amp;self) -&gt; u32 {
        // `self` должен быть сопоставлен (проверен на соответствие),
        // поскольку поведение этого метода зависит от варианта `self`
        // `self` имеет тип `&amp;List`, а `*self` имеет тип `List`, сопоставление на
        // конкретном типе `T` предпочтительнее, чем сопоставление по ссылке `&amp;T`
        match *self {
            // Мы не можем завладеть `tail`, т.к. `self` заимствован;
            // вместо этого возьмём ссылку на `tail`
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // Базовый случай: Пустой список имеет нулевую длину
            Nil =&gt; 0
        }
    }

    // Возвращаем представление списка в виде (размещённой в куче) строки
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` похож на `print!`, но возвращает строку
                // размещённую в куче, вместо вывода на консоль
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // Создаём пустой связанный список
    let mut list = List::new();

    // Присоединяем несколько элементов
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Отображаем окончательное состояние списка
    println!(&quot;размер связанного списка: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-11" id="Смотрите-также-11">Смотрите также:</a></h3>
<p><a href="custom_types/enum/std/box.html"><code>Box</code></a> и <a href="custom_types/enum/fn/methods.html"><code>методы</code></a></p>
<h1><a class="header" href="#Константы" id="Константы">Константы</a></h1>
<p>В Rust есть два типа констант, которые могут быть объявлены
в любой области видимости, включая глобальную. Оба требуют явной аннотации типа:</p>
<ul>
<li><code>const</code>: Неизменяемая переменная (в общем случае).</li>
<li><code>static</code>: Возможно, <code>изменяемая</code> переменная с временем жизни <a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code></a>. Статическое время жизни выводится и не должно быть указано. Доступ или модификация изменяемой статической переменной <a href="custom_types/../unsafe.html">небезопасно (см. <code>unsafe</code>)</a>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Константы объявлены в глобальной области видимости.
static LANGUAGE: &amp;str = &quot;Rust&quot;;
const THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // Получаем доступ к константе внутри функции
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // Получаем доступ к константе внутри функции main
    println!(&quot;Это язык {}&quot;, LANGUAGE);
    println!(&quot;Установим предел, равный {}&quot;, THRESHOLD);
    println!(&quot;Число {} {} предела&quot;, n, if is_big(n) { &quot;больше&quot; } else { &quot;меньше&quot; });

    // Ошибка! `const` нельзя изменить.
    THRESHOLD = 5;
    // ИСПРАВЬТЕ ^ Закомментируйте эту строчку
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-12" id="Смотрите-также-12">Смотрите также:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md">RFC для <code>const</code>/<code>static</code></a>,
<a href="custom_types/../scope/lifetime/static_lifetime.html">время жизни <code>'static</code></a></p>
<h1><a class="header" href="#Связывание-переменных" id="Связывание-переменных">Связывание переменных</a></h1>
<p>Rust предоставляет безопасность типов с помощью статической типизации.
Тип переменной может быть указан при объявление связи с переменной.
Тем не менее, в большинстве случаев, компилятор сможет определить тип переменной из контекста.</p>
<p>Значения (как и литералы) могут быть привязаны к переменным, используя оператор <code>let</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // скопировать значение `an_integer` в `copied_integer`
    let copied_integer = an_integer;

    println!(&quot;Целое: {:?}&quot;, copied_integer);
    println!(&quot;Логическое: {:?}&quot;, a_boolean);
    println!(&quot;Встречайте единичное значение: {:?}&quot;, unit);

    // Компилятор предупреждает о неиспользуемых переменных; эти предупреждения можно
    // отключить используя подчёркивание перед именем переменной
    let _unused_variable = 3u32;
    let noisy_unused_variable = 2u32;
    // ИСПРАВЬТЕ ^ Добавьте подчёркивание
}
</code></pre></pre>
<h1><a class="header" href="#Изменяемость" id="Изменяемость">Изменяемость</a></h1>
<p>По умолчанию связывание переменных является неизменяемым,
но с помощью модификатора <code>mut</code> можно разрешить изменения.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Перед изменением: {}&quot;, mutable_binding);

    // Ok
    mutable_binding += 1;

    println!(&quot;После изменения: {}&quot;, mutable_binding);

    // Ошибка!
    _immutable_binding += 1;
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку
}
</code></pre></pre>
<p>Компилятор будет выводить подробные сообщения об ошибках, связанных с изменяемостью.</p>
<h1><a class="header" href="#Область-и-Затенение" id="Область-и-Затенение">Область и Затенение</a></h1>
<p>Связывание переменных имеет локальную область видимости, и живут эти переменные в <em>блоке</em>.
Блок — набор инструкций, заключённый между фигурными скобками <code>{}</code>.
Кроме того, допускается <a href="https://en.wikipedia.org/wiki/Variable_shadowing">затенение переменных.</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Эта переменная живёт в функции main
    let long_lived_binding = 1;

    // Это блок, он имеет меньшую область видимости, чем функция main
    {
        // Эта переменная существует только в этом блоке
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);

        // Эта переменная *затеняет* собой внешнюю
        let long_lived_binding = 5_f32;

        println!(&quot;inner long: {}&quot;, long_lived_binding);
    }
    // Конец блока

    // Ошибка! `short_lived_binding` нет в этой области видимости
    println!(&quot;outer short: {}&quot;, short_lived_binding);
    // ИСПРАВЬТЕ ^ Закомментируйте строку

    println!(&quot;outer long: {}&quot;, long_lived_binding);

    // Это связывание так же *скрывает* собой предыдущие
    let long_lived_binding = 'a';

    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<h1><a class="header" href="#Предварительное-объявление" id="Предварительное-объявление">Предварительное объявление</a></h1>
<p>Можно сначала объявить связь с переменной, а инициализировать её позже.
Однако, такая форма используется редко,
так как может привести к использованию неинициализированных переменных.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Объявляем связь с переменной
    let a_binding;

    {
        let x = 2;

        // Инициализируем связь
        a_binding = x * x;
    }

    println!(&quot;связь а: {}&quot;, a_binding);

    let another_binding;

    // Ошибка! Использование неинициализированной связи с переменной
    println!(&quot;другая связь: {}&quot;, another_binding);
    // ИСПРАВЬТЕ ^ Закомментируйте строку

    another_binding = 1;

    println!(&quot;другая связь: {}&quot;, another_binding);
}
</code></pre></pre>
<p>Компилятор запрещает использование неинициализированных переменных,
так как это привело бы к неопределённому поведению.</p>
<h1><a class="header" href="#Типы" id="Типы">Типы</a></h1>
<p>Rust предоставляет несколько механизмов изменения или определения примитивных
и пользовательских типов:</p>
<ul>
<li><a href="types/cast.html">Приведение</a> между примитивными типами</li>
<li>Указание желаемого типа <a href="types/literals.html">литералы</a></li>
<li>Использование <a href="types/inference.html">вывода типов</a></li>
<li><a href="types/alias.html">Псевдонимы</a> типов</li>
</ul>
<h1><a class="header" href="#Приведение-типов" id="Приведение-типов">Приведение типов</a></h1>
<p>Rust не предусматривает неявного преобразования типов (принудительное) между примитивными типами.
Но, явное преобразование типов (casting) можно выполнить используя ключевое слово <code>as</code>.</p>
<p>Правила, используемые для преобразование внутренних типов, такие же, как в языке C,
за исключением тех случаев, когда преобразование типов в языке C
вызывает неопределённое поведение.
Поведение всех приведений между встроенными типами чётко определено в Rust.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Убрать все предупреждения
// которые вызываются переполнением при преобразование типов.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // Ошибка ! Нет неявного преобразования
    let integer: u8 = decimal;
    // ИСПРАВЬТЕ ^ Закомментируйте данную строку

    // Явное преобразование
    let integer = decimal as u8;
    let character = integer as char;

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // Когда преобразовывается любое значение в беззнаковый тип T
    // std::T::MAX + 1 добавляется или вычитается до тех пор, пока значение
    // не будет помещаться в новый тип.

    // 1000 поместится в u16
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // Подробнее. Первые 8 младших битов (LSB) сохраняются,
    // а старшие биты (MSB) будут усечены.
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // Для положительных чисел результатом будет остаток от деления
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // Когда значение преобразовывается в знаковый тип,
    // побитовый результат будет таким же, как и
    // первое преобразование к соответствующему типу без знака. Если старший бит этого значения
    // равен 1, то это значение отрицательное.

    // За исключением случая, когда значение умещается в тип.
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);
    // 128 as u8 -&gt; 128, дополнительный код которого в 8 битах:
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // повторяем примеры
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as a i8 is : {}&quot;, 1000 as i8);
    // и дополнительный код 232 - это -24
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
}
</code></pre></pre>
<h1><a class="header" href="#Литералы" id="Литералы">Литералы</a></h1>
<p>Числовые литералы могут быть обозначены добавлением типа в качестве суффикса. Например,
чтобы указать, что литерал <code>42</code> должен иметь тип <code>i32</code>, необходимо написать <code>42i32</code>.</p>
<p>Тип литералов без суффикса будет зависеть от того, как они используются. Если нет никаких
ограничений, то компилятор будет использовать <code>i32</code> для целочисленных литералов, а <code>f64</code> для
литералов с плавающей точкой.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Литералы с суффиксами. Их тип известен при инициализации.
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // Литералы без суффиксов. Их тип будет зависеть от того, как их используют.
    let i = 1;
    let f = 1.0;

    // `size_of_val` возвращает размер переменной в байтах
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>В предыдущем коде используются некоторые вещи, которые не были объяснены ранее.
Вот краткое объяснение для нетерпеливых читателей:</p>
<ul>
<li><code>fun(&amp;foo)</code> используется для передаче аргумента в функцию <em>по ссылке</em>, вместо
передачи по значению (<code>fun(foo)</code>). Подробнее см. <a href="types/scope/borrow.html">заимствование</a> или соответствующую
<a href="http://rurust.github.io/rust_book_ru/src/references-and-borrowing.html">главу в книге</a>.</li>
<li><code>std::mem::size_of_val</code> является функцией, но вызывается с указанием <em>полного пути</em>.
Код можно разделить на логические единицы, называемые <em>модулями</em>. В данном случае,
функция определена в модуле <code>mem</code>, а модуль <code>mem</code> определён в <em>контейнере</em> <code>std</code>.
Подробнее см. <a href="types/mod.html">модули</a> и <a href="types/crates.html">контейнеры</a>,
а так же соответствующую 
<a href="http://rurust.github.io/rust_book_ru/src/crates-and-modules.html">главу в книге</a></li>
</ul>
<h1><a class="header" href="#Вывод-типов" id="Вывод-типов">Вывод типов</a></h1>
<p>Движок вывода типов весьма умён. Он делает куда больше,
чем просто смотрит на тип <a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">r-value</a> при инициализации.
Он также смотрит, как используется значение после инициализации, чтобы
вывести его тип. Вот расширенный пример вывода типов:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Благодаря выведению типов компилятор знает, `elem` имеет тип - u8.
    let elem = 5u8;

    // Создадим пустой вектор (расширяемый массив).
    let mut vec = Vec::new();
    // В данном месте компилятор не знает точный тип `vec`, он лишь знает,
    // что это вектор чего-то там (`Vec&lt;_&gt;`).

    // Добавляем `elem` в вектор.
    vec.push(elem);
    // Ага! Теперь компилятор знает, что `vec` - это вектор, который хранит в себе тип `u8`
    // (`Vec&lt;u8&gt;`)
    // ЗАДАНИЕ ^ Попробуйте закомментировать строку `vec.push(elem)`

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>Не потребовалось никакой аннотации типов переменных, компилятор счастлив, как и программист!</p>
<h1><a class="header" href="#Псевдонимы" id="Псевдонимы">Псевдонимы</a></h1>
<p>Оператор type используется, чтобы задать новое имя существующему типу.
Имя типа должно быть в стиле <code>CamelCase</code>, иначе компилятор выдаст предупреждение.
Исключением являются примитивные типы: <code>usize</code>, <code>f32</code> и другие.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `NanoSecond` это новое имя для `u64`.
type NanoSecond = u64;
type Inch = u64;

// Используйте этот атрибут, чтобы не выводить предупреждение
// о именах не в стиле CamelCase
#[allow(non_camel_case_types)]
type u64_t = u64;
// ЗАДАНИЕ ^ Попробуйте удалить атрибут

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // Обратите внимание, что псевдонимы *не предоставляют* никакой
    // дополнительной безопасности типов, так как *не являются* новыми типами
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>Основное применение псевдонимов — сокращение размера кода: например, тип <code>IoResult&lt;T&gt;</code> является
псевдонимом типа Result&lt;T, IoError&gt;.</p>
<h3><a class="header" href="#Смотрите-также-13" id="Смотрите-также-13">Смотрите также:</a></h3>
<p><a href="types/attribute.html">Атрибуты</a></p>
<h1><a class="header" href="#Приведение-типов-1" id="Приведение-типов-1">Приведение типов</a></h1>
<p>Приведение типов в Rust осуществляется с помощью <a href="trait.html">типажей</a>.
В общем, при приведении к типу используются <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> и <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>,
но есть и более специфические типажи для часто используемых
случаев, например, для конвертации в <code>String</code> и обратно.</p>
<h1><a class="header" href="#from-and-into" id="from-and-into"><code>From</code> and <code>Into</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> traits are inherently linked, and this is actually part of
its implementation. If you are able to convert type A from type B, then it
should be easy to believe that we should be able to convert type B to type A.</p>
<h2><a class="header" href="#from" id="from"><code>From</code></a></h2>
<p>The <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> trait allows for a type to define how to create itself from another
type, hence providing a very simple mechanism for converting between several
types. There are numerous implementations of this trait within the standard
library for conversion of primitive and common types.</p>
<p>For example we can easily convert a <code>str</code> into a <code>String</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let my_str = &quot;hello&quot;;
let my_string = String::from(my_str);
#}</code></pre></pre>
<p>We can do similar for defining a conversion for our own type.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h2><a class="header" href="#into" id="into"><code>Into</code></a></h2>
<p>The <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> trait is simply the reciprocal of the <code>From</code> trait. That is, if you
have implemented the <code>From</code> trait for your type you get the <code>Into</code>
implementation for free.</p>
<p>Using the <code>Into</code> trait will typically require specification of the type to
convert into as the compiler is unable to determine this most of the time.
However this is a small trade-off considering we get the functionality for free.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // Try removing the type declaration
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h1><a class="header" href="#to-and-from-strings" id="to-and-from-strings">To and from Strings</a></h1>
<h2><a class="header" href="#tostring" id="tostring"><code>ToString</code></a></h2>
<p>To convert any type to a <code>String</code> it is as simple as implementing the <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>
trait for the type.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::string::ToString;

struct Circle {
    radius: i32
}

impl ToString for Circle {
    fn to_string(&amp;self) -&gt; String {
        format!(&quot;Circle of radius {:?}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<h2><a class="header" href="#parsing-a-string" id="parsing-a-string">Parsing a String</a></h2>
<p>One of the more common types to convert a string into is a number. The idiomatic
approach to this is to use the <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a> function and provide the type for the
function to parse the string value into, this can be done either without type
inference or using the 'turbofish' syntax.</p>
<p>This will convert the string into the type specified so long as the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>
trait is implemented for that type. This is implemented for numerous types
within the standard library. To obtain this functionality on a user defined type
simply implement the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait for that type.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!{&quot;Sum: {:?}&quot;, sum};
}
</code></pre></pre>
<h1><a class="header" href="#Выражения" id="Выражения">Выражения</a></h1>
<p>Программы на языке Rust - это (в основном) набор последовательных операторов:</p>
<pre><code>fn main() {
    // оператор
    // оператор
    // оператор
}
</code></pre>
<p>Существует несколько типов операторов в Rust.
Наиболее распространённые - оператор связывания и выражение, заканчивающееся <code>;</code>:</p>
<pre><code>fn main() {
    // оператор связывания
    let x = 5;

    // оператор выражения
    x;
    x + 1;
    15;
}
</code></pre>
<p>Блоки так же могут быть частью оператора выражения.
Они используются в качестве <a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">r-values</a> при присваивание.
Последнее выражение в блоке будет присвоено <a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">l-value</a>.
Однако, если последнее выражение в блоке оканчивается точкой с запятой,
в качестве значения будет возвращено <code>()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // Результат этого выражение будет присвоен переменной `y`
        x_cube + x_squared + x
    };

    let z = {
        // Т.к это выражение оканчивается на `;`, переменной `z` будет присвоен `()`
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<h1><a class="header" href="#Управление-потоком" id="Управление-потоком">Управление потоком</a></h1>
<p>Неотъемлемой частью любого языка программирования является изменение потоков управления:
<code>if</code>/<code>else</code>, <code>for</code> и другие. Давайте поговорим о них в языке Rust.</p>
<h1><a class="header" href="#ifelse" id="ifelse">if/else</a></h1>
<p>Ветвление с помощью <code>if</code>-<code>else</code> такое же, как и в других языка программирования.
В отличие от многих других языков программирования, логические условия не должны быть заключены
в круглые скобки и после каждого условия должен следовать блок.
Условия <code>if</code>-<code>else</code> являются выражениями, и все ветки должны возвращать одинаковый тип данных.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} — отрицательное&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{} — положительное&quot;, n);
    } else {
        print!(&quot;{} — нуль&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, малое по модулю число, умножим его в десять раз&quot;);

            // Это выражение вернёт `i32`.
            10 * n
        } else {
            println!(&quot;, большое по модулю число, уменьшим его вдвое&quot;);

            // И это выражение вернёт `i32`.
            n / 2
            // ЗАДАНИЕ ^ Попробуйте отбросить значение, добавив точку с запятой.
        };
    //   ^ Не забудьте добавить тут точку с запятой! Все операторы `let` требуют её..

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<h1><a class="header" href="#loop" id="loop">loop</a></h1>
<p>Rust предоставляет ключевое слово <code>loop</code> для обозначения бесконечного цикла.</p>
<p>Оператор <code>break</code> используется чтобы выйти из цикла в любое время, оператор
<code>continue</code> используется чтобы пропустить оставшуюся часть цикла и начать новую итерацию.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut count = 0u32;

    println!(&quot;Давайте считать до бесконечности!&quot;);

    // Бесконечный цикл
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;три&quot;);

            // Пропустить оставшуюся часть цикла
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;Всё, достаточно&quot;);

            // Выйти из цикла
            break;
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#Вложенность-и-метки" id="Вложенность-и-метки">Вложенность и метки</a></h1>
<p>Можно прерывать выполнение внешних циклов с помощью <code>break</code> или <code>continue</code>,
когда речь заходит о вложенных циклах.
Для этого циклы должны быть обозначены метками вроде <code>'label</code>,
а метки должны быть переданы операторам <code>break</code> или <code>continue</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Вошли во внешний цикл&quot;);

        'inner: loop {
            println!(&quot;Вошли во внутренний цикл&quot;);

            // Это прервёт лишь внутренний цикл
            //break;

            // Это прервёт внешний цикл
            break 'outer;
        }

        println!(&quot;Эта точка не будет достигнута&quot;);
    }

    println!(&quot;Вышли из внешнего цикла&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#Возврат-из-циклов" id="Возврат-из-циклов">Возврат из циклов</a></h1>
<p>Одним из видов использования цикла <code>loop</code> является повторение операции, пока
она не будет выполнена. Если операция возвращает значение, вам может
потребоваться передать его в другую часть кода: поместите его после <code>break</code>,
и оно будет возвращено выражением <code>loop</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<h1><a class="header" href="#while" id="while">while</a></h1>
<p>Ключевое слово <code>while</code> используется для создания цикла, который будет выполняться,
пока условие истинно.</p>
<p>Давайте напишем печально известный <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> используя цикл <code>while</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Переменная счётчик
    let mut n = 1;

    // Цикл while будет работать, пока `n` меньше 101
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // Увеличиваем значение счётчика
        n += 1;
    }
}
</code></pre></pre>
<h1><a class="header" href="#for-loops" id="for-loops">for loops</a></h1>
<h2><a class="header" href="#for-and-range" id="for-and-range">for and range</a></h2>
<p>Конструкция <code>for in</code> может быть использована для итерации по <code>Итераторам (Iterator)</code>.
Один из самых простых способов создать итератор это использовать
диапазон значений <code>a..b</code>. Это вернёт нам значения от <code>a</code> (включительно) до <code>b</code>
(исключительно) за один шаг.</p>
<p>Давайте напишем FizzBuzz, используя <code>for</code> вместо <code>while</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `n` будет принимать значения: 1, 2, ..., 100 с каждой итерации
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<p>Alternatively, <code>a..=b</code> can be used for a range that is inclusive on both ends.
The above can be written as:</p>
<pre><pre class="playpen"><code class="language-rust editable">#![feature(inclusive_range_syntax)]

fn main() {
    // `n` will take the values: 1, 2, ..., 100 in each iteration
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#for-and-iterators" id="for-and-iterators">for and iterators</a></h2>
<p>The <code>for in</code> construct is able to interact with an <code>Iterator</code> in several ways.
As discussed in with the <a href="flow_control/trait/iter.html">Iterator</a> trait, if not specified, the <code>for</code>
loop will apply the <code>into_iter</code> function on the collection provided to convert
the collection into an iterator. This is not the only means to convert a
collection into an iterator however, the other functions available include
<code>iter</code> and <code>iter_mut</code>.</p>
<p>These 3 functions will return different views of the data within your
collection.</p>
<ul>
<li><code>iter</code> - This borrows each element of the collection through each iteration.
Thus leaving the collection untouched and available for reuse after the loop.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>into_iter</code> - This consumes the collection so that on each iteration the exact
data is provided. Once the collection has been consumed it is no longer
available for reuse as it has been 'moved' within the loop.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>iter_mut</code> - This mutably borrows each element of the collection, allowing for
the collection to be modified in place.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        match name {
            &amp;mut &quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<p>In the above snippets note the type of <code>match</code> branch, that is the key
difference in the types or iteration. The difference in type then of course
implies differing actions that are able to be performed.</p>
<h3><a class="header" href="#Смотрите-также-14" id="Смотрите-также-14">Смотрите также:</a></h3>
<p><a href="flow_control/trait/iter.html">Итераторы (Iterator)</a></p>
<h1><a class="header" href="#match" id="match">match</a></h1>
<p>Rust предоставляет ключевое слово <code>match</code>, которое используется для проверки на
соответствие шаблону. <code>match</code> можно использовать как <code>switch</code> в языке C.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let number = 13;
    // ЗАДАНИЕ ^ Попробуйте присвоить `number` другое значение

    println!(&quot;Tell me about {}&quot;, number);
    match number {
        // Сопоставление с одним значением
        1 =&gt; println!(&quot;One!&quot;),
        // Сопоставление с несколькими значениями
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
        // Сопоставление с диапазоном значений
        13...19 =&gt; println!(&quot;A teen&quot;),
        // Обработка остальных случаев
        _ =&gt; println!(&quot;Ain't special&quot;),
    }

    let boolean = true;
    // Match так же является выражением
    let binary = match boolean {
        // Ветви match должны обработать все возможные значения переменной
        false =&gt; 0,
        true =&gt; 1,
        // ЗАДАНИЕ ^ Попробуйте закомментировать эту ветвь
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<h1><a class="header" href="#Деструктуризация" id="Деструктуризация">Деструктуризация</a></h1>
<p>Блок <code>match</code> может  деструктурировать элементы в различных формах.</p>
<ul>
<li><a href="flow_control/match/destructuring/destructure_enum.html">Перечисления</a></li>
<li><a href="flow_control/match/destructuring/destructure_pointers.html">Указатели</a></li>
<li><a href="flow_control/match/destructuring/destructure_structures.html">Структуры</a></li>
<li><a href="flow_control/match/destructuring/destructure_tuple.html">Кортежи</a></li>
</ul>
<h1><a class="header" href="#Кортежи-1" id="Кортежи-1">Кортежи</a></h1>
<p>Кортежи можно деструктурировать с помощью <code>match</code> следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (0, -2);
    // ЗАДАНИЕ ^ Попробуйте другие значения для `pair`

    println!(&quot;Tell me about {:?}&quot;, pair);
    // Match можно использовать для деструктуризации кортежей
    match pair {
        // Деструктурируем два значения
        (0, y) =&gt; println!(&quot;Первое значение `0`, а `y` равно `{:?}`&quot;, y),
        (x, 0) =&gt; println!(&quot;`x` равно `{:?}`, а второе значение `0`&quot;, x),
        _      =&gt; println!(&quot;Неважно, какого они значения&quot;),
         // `_` означает, что значение не будет связано с переменной
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-15" id="Смотрите-также-15">Смотрите также:</a></h3>
<p><a href="flow_control/match/destructuring/primitives/tuples.html">Tuples</a></p>
<h1><a class="header" href="#Перечисления-1" id="Перечисления-1">Перечисления</a></h1>
<p>Деструктуризация <code>enum</code> происходит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust editable">// `allow` необходим, чтобы компилятор не выводил предупреждения,
// т.к используется только один вариант
#[allow(dead_code)]
enum Color {
    // Эти 3 перечисления определяют цвет по названию.
    Red,
    Blue,
    Green,
    // Остальные используют `u32` кортежи для идентификации цветовых моделей.
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // ЗАДАНИЕ ^ Попробуйте другие значения для `color`

    println!(&quot;Какой это цвет?&quot;);
    // `enum` может быть деструктурирован с помощью `match`.
    match color {
        Color::Red   =&gt; println!(&quot;Красный цвет!&quot;),
        Color::Blue  =&gt; println!(&quot;Синий цвет!&quot;),
        Color::Green =&gt; println!(&quot;Зелёный цвет!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Красный: {}, зелёный: {}, и синий: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Тон: {}, насыщенность: {}, значение: {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Тон: {}, насыщенность: {}, светлота: {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Голубой: {}, пурпурный: {}, жёлтый: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Голубой: {}, пурпурный: {}, жёлтый: {}, key (чёрный): {}!&quot;,
                c, m, y, k),
        // Нет необходимости в других ветвях, т.к были рассмотрены все варианты
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-16" id="Смотрите-также-16">Смотрите также:</a></h3>
<p><a href="flow_control/match/destructuring/../../../attribute/unused.html"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">цветовая модель</a> и <a href="flow_control/match/destructuring/../../../custom_types/enum.html"><code>перечисления</code></a></p>
<h1><a class="header" href="#Указатели-и-ссылки" id="Указатели-и-ссылки">Указатели и ссылки</a></h1>
<p>Для указателей необходимо различать деструктуризацию и разыменование, 
поскольку это разные концепции, которые используются иначе, чем в языке <code>С</code>.</p>
<ul>
<li>Разыменование использует <code>*</code></li>
<li>Деструктуризация использует <code>&amp;</code>, <code>ref</code> и <code>ref mut</code></li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Присваиваем ссылку на тип `i32`. 
    // Символ `&amp;` означает, что присваивается ссылка.
    let reference = &amp;4;

    match reference {
        // Если `reference` - это шаблон, который сопоставляется с `&amp;val`,
        // то это приведёт к сравнению:
        // `&amp;i32`
        // `&amp;val`
        // ^ Мы видим, что если отбросить сопоставляемые `&amp;`, 
        // то переменной `val` должно быть присвоено `i32`.
        &amp;val =&gt; println!(&quot;Получаем значение через деструктуризацию: {:?}&quot;, val),
    }

    // Чтобы избежать символа `&amp;`, нужно разыменовывать ссылку до сопоставления.
    match *reference {
        val =&gt; println!(&quot;Получаем значение через разыменование: {:?}&quot;, val),
    }

    // Что если у нас нет ссылки? `reference` была с `&amp;`,
    // потому что правая часть была ссылкой. Но это не ссылка, 
    // потому что правая часть ею не является.
    let _not_a_reference = 3;

    // Rust предоставляет ключевое слово `ref` именно для этой цели. 
    // Оно изменяет присваивание так, что создаётся ссылка для элемента. 
    // Теперь ссылка присвоена.
    let ref _is_a_reference = 3;

    // Соответственно, для определения двух значений без ссылок, 
    // ссылки можно назначить с помощью `ref` и `ref mut`.
    let value = 5;
    let mut mut_value = 6;

    // Используйте ключевое слово `ref` для создания ссылки.
    match value {
        ref r =&gt; println!(&quot;Получили ссылку на значение: {:?}&quot;, r),
    }

    // Используйте `ref mut` аналогичным образом.
    match mut_value {
        ref mut m =&gt; {
            // Получаем ссылку. Её нужно разыменовать, 
            // прежде чем мы сможем что-то добавить.
            *m += 10;
            println!(&quot;Мы добавили 10. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<h1><a class="header" href="#Структуры-1" id="Структуры-1">Структуры</a></h1>
<p><code>Структуры</code> могут быть деструктурированы следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    struct Foo { x: (u32, u32), y: u32 }

    // деструктуризация члена структуры
    let foo = Foo { x: (1, 2), y: 3 };
    let Foo { x: (a, b), y } = foo;

    println!(&quot;a = {}, b = {},  y = {} &quot;, a, b, y);

    // Вы можете деструктурировать структуру и переименовывать переменные,
    // порядок при этом не важен

    let Foo { y: i, x: j } = foo;
    println!(&quot;i = {:?}, j = {:?}&quot;, i, j);

    // а так же можно проигнорировать часть переменных:
    let Foo { y, .. } = foo;
    println!(&quot;y = {}&quot;, y);

    // следующий код выдаст ошибку: в шаблоне нет упоминания поля `x`
    // let Foo { y } = foo;
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-17" id="Смотрите-также-17">Смотрите также:</a></h3>
<p><a href="flow_control/match/destructuring/../../../custom_types/structs.html">стуктуры</a>, <a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">шаблон ref</a></p>
<h1><a class="header" href="#Ограничители-шаблонов" id="Ограничители-шаблонов">Ограничители шаблонов</a></h1>
<p>Внутри конструкции <code>match</code> можно добавить <em>ограничитель шаблонов</em>
для фильтрации возможных вариантов.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (2, -2);
    // ЗАДАНИЕ ^ Попробуйте разные значения `pair`

    println!(&quot;Расскажи мне о {:?}&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;Близнецы&quot;),
        // Данное ^ `условие if` является ограничителем шаблонов
        (x, y) if x + y == 0 =&gt; println!(&quot;Антиматерия, бабах!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;Первое число нечётно&quot;),
        _ =&gt; println!(&quot;Нет корреляции...&quot;),
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-18" id="Смотрите-также-18">Смотрите также:</a></h3>
<p><a href="flow_control/match/primitives/tuples.html">Tuples</a></p>
<h1><a class="header" href="#Связывание" id="Связывание">Связывание</a></h1>
<p>Косвенный доступ к переменной делает невозможным ветвление и использование
переменной без повторной привязки. <code>match</code> предоставляет символ <code>@</code> 
для привязки значения к имени:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Функция под названием `age`, которая возвращает `u32`.
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Скажите мне, к какой возрастной категории вы относитесь?&quot;);

    match age() {
        0             =&gt; println!(&quot;Мне кажется, что я ещё не родился...&quot;),
        // Можно использовать `match` для конкретного значения в пределе 1 ... 12, но
        // как тогда определять возраст ребёнка, например? Вместо этого, свяжем `n` с
        // последовательностью от 1 до 12. Теперь мы можем сообщить о возрасте.
        n @ 1  ... 12 =&gt; println!(&quot;Я ребёнок! Мне {:?} лет.&quot;, n),
        n @ 13 ... 19 =&gt; println!(&quot;Я подросток. Мне {:?} лет.&quot;, n),
        // Больше пределов нет. Возвращаем результат.
        n             =&gt; println!(&quot;Я уже довольно старый, мне {:?}.&quot;, n),
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-19" id="Смотрите-также-19">Смотрите также:</a></h3>
<p><a href="flow_control/match/fn.html">функции</a></p>
<h1><a class="header" href="#if-let" id="if-let">if let</a></h1>
<p>В некоторых случаях использование <code>match</code> выглядит неуклюже. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Make `optional` of type `Option&lt;i32&gt;`
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
        // ^ Needed 2 indentations just so we could destructure
        // `i` from the option.
    },
    _ =&gt; {},
    // ^ Required because `match` is exhaustive. Doesn't it seem
    // like wasted space?
};

#}</code></pre></pre>
<p><code>if let</code> намного компактнее и выразительнее для данного случая и, кроме того, позволяет рассмотреть различные варианты ошибок.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Все переменные типа `Option&lt;i32&gt;`
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // Конструкция `if let` читает, как: &quot;Если `let` деструктуризирует `number` в
    // `Some(i)`, выполнить блок (`{}`).
    if let Some(i) = number {
        println!(&quot;Соответствует {:?}!&quot;, i);
    }

    // Если нужно указать, что делать, в случае ошибки, можно добавить else:
    if let Some(i) = letter {
        println!(&quot;Соответствует {:?}!&quot;, i);
    } else {
        // Ошибка деструктуризации. Переходим к обработке ошибки.
        println!(&quot;Не соответствует числу. Давайте попробуем строку!&quot;);
    };

    // Добавляем ещё одну ситуацию несоответствия образцу.
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Соответствует {:?}!&quot;, i);
    // Оцените условие `else if`, чтобы увидеть, 
    // должна ли быть альтернативная ветка отказа:
    } else if i_like_letters {
        println!(&quot;Не соответствует числу. Давайте попробуем строку!&quot;);
    } else {
        // Рассматриваем ложное условие. Эта ветвь по умолчанию:
        println!(&quot;Мне не нравится сравнивать строки. Давайте возьмём смайлик :)!&quot;);
    };
}
</code></pre></pre>
<p>Точно так же, <code>if let</code> может быть использован для сравнения любого значения перечисления:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Наш пример перечисления
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // Создание переменных примера
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);
    
    // Переменная a соответствует Foo::Bar
    if let Foo::Bar = a {
        println!(&quot;a is foobar&quot;);
    }
    
    // Переменная b не соответствует Foo::Bar
    // So this will print nothing
    if let Foo::Bar = b {
        println!(&quot;b is foobar&quot;);
    }
    
    // Переменная c соответствует Foo::Qux, которая имеет значение
    // аналогичное Some() как в предыдущем примере:
    if let Foo::Qux(value) = c {
        println!(&quot;c is {}&quot;, value);
    }
}
</code></pre></pre>
<p>Другое преимущество: <code>if let</code> позволяет сопоставлять не параметризованные варианты перечисления, даже если перечисление не <code>#[derive(PartialEq)]</code>, и мы не имплементировали <code>PartialEq</code> для них. В некоторых случаях, классический <code>if Foo::Bar == a</code> не работает, потому что такие перечисления не могут быть равны. Однако, <code>if let</code> работает.</p>
<p>Хотите вызов? Исправьте следующий пример с использованием <code>if let </code>:</p>
<pre><code class="language-rust editable ignore">// Для это перечисление намеренно не добавлен #[derive(PartialEq)],
// и мы не реализовывали для него PartialEq. Вот почему сравнение Foo::Bar==a терпит неудачу.
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // Переменная соответствует Foo::Bar
    if Foo::Bar == a {
    // ^-- это вызовет ошибку компиляции. Используйте `if let` вместо этого.
        println!(&quot;a is foobar&quot;);
    }
}
</code></pre>
<h3><a class="header" href="#Смотрите-также-20" id="Смотрите-также-20">Смотрите также:</a></h3>
<p><a href="flow_control/../custom_types/enum.html"><code>enum</code></a>, <a href="flow_control/../std/option.html"><code>Option</code></a>, и <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<h1><a class="header" href="#while-let" id="while-let">while let</a></h1>
<p>Так же, как и<code>if let</code>, <code>while let</code> может сделать неудобный <code>match</code>
более терпимым. Рассмотрим следующий пример, в котором мы увеличиваем значение <code>i</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Создадим переменную `optional` с типом `Option&lt;i32&gt;`
let mut optional = Some(0);

// Неоднократно повторим наш тест.
loop {
    match optional {
        // Если `optional` деструктурируется, выполним следующий блок.
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Больше 9, уходим отсюда!&quot;);
                optional = None;
            } else {
                println!(&quot;`i` равен `{:?}`. Попробуем еще раз.&quot;, i);
                optional = Some(i + 1);
            }
            // ^ Требует 3 уровня вложенности!
        },
        // Выходим из цикла в случаи ошибки деструктуризации:
        _ =&gt; { break; }
        // ^ Зачем это нужно? Должен быть способ сделать это лучше!
    }
}
#}</code></pre></pre>
<p>Использование <code>while let</code> делает этот пример немного приятнее:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Создадим переменную `optional` с типом `Option&lt;i32&gt;`
    let mut optional = Some(0);

    // Это можно прочитать так: &quot;Пока `let` деструктурирует `optional` в
    // `Some(i)`, выполняем блок (`{}`). В противном случае `break`.
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Больше 9, уходим отсюда!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` равен `{:?}`. Попробуем ещё раз.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ Меньше смещаемся вправо, к тому же
        // нет необходимости обрабатывать ошибки.
    }
    // ^ К `if let` можно добавить дополнительный блок `else`/`else if`
    // `while let` подобного нет.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-21" id="Смотрите-также-21">Смотрите также:</a></h3>
<p><a href="flow_control/custom_types/enum.html"><code>enum</code></a>, <a href="flow_control/std/option.html"><code>Option</code></a>, and the <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<h1><a class="header" href="#Функции" id="Функции">Функции</a></h1>
<p>Функции объявляются с помощью ключевого слова <code>fn</code>. Их аргументы имеют явно заданный тип,
как у переменных, и, если функция возвращает значение,
возвращаемый тип должен быть указан после стрелки <code>-&gt;</code>.</p>
<p>Последнее выражение в функции будет использовано как возвращаемое значение.
Так же можно использовать оператор <code>return</code>, чтобы вернуть значение из функции раньше,
даже из цикла или оператора <code>if</code>.</p>
<p>Давайте перепишем FizzBuzz используя функции!</p>
<pre><pre class="playpen"><code class="language-rust editable">// В отличие от С/С++, нет никаких ограничений касаемо порядка определений функций
fn main() {
    // Можно использовать функцию здесь, а определить где-нибудь потом
    fizzbuzz_to(100);
}

// Функция, возвращающая логическое значение
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // Граничный случай, ранний возврат
    if rhs == 0 {
        return false;
    }

    // Это - выражение, ключевое слово `return` здесь не требуется
    lhs % rhs == 0
}

// Функция, которая «не возвращает» значение, на самом деле возвращает единичный тип `()`
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// Когда функция возвращает `()`, возвращаемый тип можно не указывать
fn fizzbuzz_to(n: u32) {
    for n in 1..n + 1 {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<h1><a class="header" href="#методы" id="методы">методы</a></h1>
<p>Методы - это функций прикреплённые к объектам. Эти методы имеют допуск к данным объекта и
его другим методам через ключевое слово <code>self</code>. Методы определяются под блоком <code>impl</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point {
    x: f64,
    y: f64,
}

// Блок реализаций, все методы `Point` идут сюда
impl Point {
    // Это статический метод
    // Статические методы не нуждаются в вызове от экземпляра
    // Эти методы, как правило, используются как конструкторы
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // Другой статический метод, берет два аргумента
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // Это метод экземпляра
    // `&amp;self` это сахар для `self: &amp;Self`, где `Self` это тип
    // вызываемого объекта. В этом месте `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` даёт допуск к полям структуры через оператор точка
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` это метод `f64` который возвращает абсолютную величину
        // вызываемого
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // Этот метод требует чтобы вызываемый объект был изменяемым
    // `&amp;mut self` сахар для `self: &amp;mut Self`
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` владеет ресурсами: два целых числа в куче
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // Этот метод &quot;съедает&quot; ресурсы вызываемого объекта
    // `self` сахар для `self: Self`
    fn destroy(self) {
        // деструктуризация `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` и `second` выходят из области видимости и освобождаются
    }
}

fn main() {
    let rectangle = Rectangle {
        // Статические методы вызываются двойными двоеточиями
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Метод экземпляра вызывается с помощью оператора точка
    // Обратите внимание, что первый аргумент `&amp;self` неявно пропускается т.е.
    // `rectangle.perimeter()` === `perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Ошибка! `rectangle` неизменяемый, но этот метод нуждается в изменяемом
    // объекте
    //rectangle.translate(1.0, 0.0);
    // ЗАДАНИЕ ^ Попробуйте удалить комментарий

    // Хорошо, изменяемый объект может вызывать изменяемые методы
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Ошибка! `destroy` вызывает &quot;съеденный&quot; `pair`
    //pair.destroy();
    // ЗАДАНИЕ ^ Попробуйте удалить комментарий
}
</code></pre></pre>
<h1><a class="header" href="#Замыкания" id="Замыкания">Замыкания</a></h1>
<p>Замыкания в Rust, так же называемые лямбда, это функции,
которые замыкают своё окружение.
Для примера, замыкание, которое захватывает значение переменной x:</p>
<pre><code class="language-rust ignore">|val| val + x
</code></pre>
<p>Синтаксис и возможности замыканий делают их очень удобными
для использования &quot;на лету&quot;. Использование замыканий похоже на использование функций.
Однако, тип входных и возвращаемых значений <em>может</em> быть выведен, а
название аргумента <em>должно</em>  быть указано.</p>
<p>Другие характеристики замыканий включают в себя:</p>
<ul>
<li>использование <code>||</code> вместо <code>()</code> для аргументов.</li>
<li>опциональное ограничения тела функции (<code>{}</code>) для одного выражения
(в противном случае обязательно).</li>
<li>возможность захвата переменных за пределами окружения</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Инкремент с помощью замыкания и функции.
    fn  function            (i: i32) -&gt; i32 { i + 1 }

    // Замыкания анонимны. Тут мы связываем их с ссылками
    // Аннотация идентичны аннотации типов функции, но является опциональной
    // как и оборачивания тела в `{}`. Эти безымянные функции
    // назначены соответствующе названным переменным.
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    let i = 1;
    // Вызов функции и замыкания.
    println!(&quot;функция: {}&quot;, function(i));
    println!(&quot;замыкание с указанием типа: {}&quot;, closure_annotated(i));
    println!(&quot;замыкание с выводом типа: {}&quot;, closure_inferred(i));

    // Замыкание не принимает аргументов, но возвращает `i32`.
    // Тип возвращаемого значения выведен автоматически.
    let one = || 1;
    println!(&quot;замыкание, возвращающее один: {}&quot;, one());

}
</code></pre></pre>
<h1><a class="header" href="#Захват" id="Захват">Захват</a></h1>
<p>Замыкания довольно гибкие и делают всё, что требуется для работы с ними без
дополнительных указаний. Это позволяет захватывать переменные, перемещая их или
заимствуя, в зависимости от необходимости.
Замыкания могут захватывать переменные:</p>
<ul>
<li>по ссылке: <code>&amp;T</code></li>
<li>по изменяемой ссылке: <code>&amp;mut T</code></li>
<li>по значению: <code>T</code></li>
</ul>
<p>Они преимущественно захватывают переменные по ссылке, если явно не указан другой
способ.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    use std::mem;

    let color = &quot;green&quot;;

    // Замыкание для вывода `color`, которое немедленно заимствует (`&amp;`)
    // `color` и сохраняет его и замыкание в переменной `print`.
    // `color` будет оставаться заимствованным до выхода `print` из области
    // видимости. `println!` требует только ссылку, поэтому он не накладывает
    // дополнительных ограничений.
    let print = || println!(&quot;`color`: {}&quot;, color);

    // Вызываем замыкание, используя заимствование.
    print();
    print();

    let mut count = 0;

    // Замыкание для увеличения `count` может принимать как `&amp;mut count`,
    // так и `count`, но использование `&amp;mut count` менее ограничено, так что
    // замыкание выбирает первый способ, т.е. немедленно заимствует `count`.
    //
    // `inc` должен быть `mut`, поскольку внутри него хранится `&amp;mut`.
    // Таким образом, вызов замыкания изменяет его, что недопустимо без `mut`.
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // Вызываем замыкание.
    inc();
    inc();

    //let reborrow = &amp;mut count;
    // ^ TODO: попробуйте раскомментировать эту строку.

    // Тип без возможности копирования.
    let movable = Box::new(3);

    // `mem::drop` требует `T`, так что захват производится по значению.
    // Копируемый тип будет скопирован в замыкание, оставив оригинальное
    // значение без изменения. Некопируемый тип должен быть перемещён, так что
    // `movable` немедленно перемещается в замыкание.
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume` поглощает переменную, так что оно может быть вызвано только раз.
    consume();
    //consume();
    // ^ TODO: Попробуйте раскомментировать эту строку.
}
</code></pre></pre>
<p>Using <code>move</code> before vertical pipes forces closure
to take ownership of captured variables:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `Vec` has non-copy semantics.
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    // `println!(&quot;There're {} elements in vec&quot;, haystack.len());`
    // ^ Uncommenting above line will result in compile-time error
    // because borrow checker doesn't allow re-using variable after it
    // has been moved.
    
    // Removing `move` from closure's signature will cause closure
    // to borrow _haystack_ variable immutably, hence _haystack_ is still
    // available and uncommenting above line will not cause an error.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-22" id="Смотрите-также-22">Смотрите также:</a></h3>
<p><a href="fn/closures/std/box.html"><code>Box</code></a> and <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<h1><a class="header" href="#Как-входные-параметры" id="Как-входные-параметры">Как входные параметры</a></h1>
<p>В то время как замыкания Rust выбирают способ захвата переменных на лету, по
большей части без указания типов, эта двусмысленность недопустима при написании
функций. При использовании замыкания в качестве входного параметра, его тип
должен быть указан с использованием одного из <code>типажей</code>. Вот они, в порядке
уменьшения ограничений:</p>
<ul>
<li><code>Fn</code>: замыкание захватывает по ссылке (<code>&amp;T</code>)</li>
<li><code>FnMut</code>: замыкание захватывает по изменяемой ссылке (<code>&amp;mut T</code>)</li>
<li><code>FnOnce</code>: замыкание захватывает по значению (<code>T</code>)</li>
</ul>
<p>Компилятор стремится захватывать переменные наименее ограничивающим способом.</p>
<p>Для примера, рассмотрим аргумент, указанный как <code>FnOnce</code>. Это означает, что
замыкание <em>может</em> захватывать <code>&amp;T</code>, <code>&amp;mut T</code>, или <code>T</code>, но компилятор в итоге
будет выбирать в зависимости от того, как захваченные переменные используются
в замыкании.</p>
<p>Это связано с тем, что если перемещение возможно, тогда любой тип заимствования
также должен быть возможен. Отметим, что обратное не верно. Если параметр
указан как <code>Fn</code>, то захват переменных как <code>&amp;mut T</code> или <code>T</code> недопустим.</p>
<p>В следующем примере попробуйте поменять местами использование <code>Fn</code>, <code>FnMut</code>, и
<code>FnOnce</code>, чтобы увидеть результат:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Функция, которая принимает замыкание в качестве аргумента и вызывает его.
fn apply&lt;F&gt;(f: F) where
    // Замыкание ничего не принимает и не возвращает.
    F: FnOnce() {
    // ^ TODO: Попробуйте изменить это на `Fn` или `FnMut`.

    f();
}

// Функция, которая принимает замыкание и возвращает `i32`.
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // Замыкание принимает `i32` и возвращает `i32`.
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;привет&quot;;
    // Некопируемый тип.
    // `to_owned` преобразует заимствованные данные в собственные.
    let mut farewell = &quot;пока&quot;.to_owned();

    // Захват двух переменных: `greeting` по ссылке и
    // `farewell` по значению.
    let diary = || {
        // `greeting` захватывается по ссылке: требует `Fn`.
        println!(&quot;Я сказал {}.&quot;, greeting);

        // Изменяемость требует от `farewell` быть захваченным
        // по изменяемой ссылке. Сейчас требуется `FnMut`.
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Потом я закричал {}.&quot;, farewell);
        println!(&quot;Теперь я могу поспать. zzzzz&quot;);

        // Ручной вызов удаления требуется от `farewell`
        // быть захваченным по значению. Теперь требуется `FnOnce`.
        mem::drop(farewell);
    };

    // Вызов функции, которая выполняет замыкание.
    apply(diary);

    // `double` удовлетворяет ограничениям типажа `apply_to_3`
    let double = |x| 2 * x;

    println!(&quot;Удвоенное 3: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-23" id="Смотрите-также-23">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, и <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#Анонимность-типов" id="Анонимность-типов">Анонимность типов</a></h1>
<p>Замыкания временно захватывают переменные из окружающих областей видимости.
Имеет ли это какие-либо последствия? Конечно. Как видите, использование
замыкания в аргументах функции требует <a href="fn/closures/generics.html">обобщённых типов</a> из-за
особенностей реализации замыканий:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// `F` должен быть обобщённым типом.
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
#}</code></pre></pre>
<p>Во время определения замыкания компилятор неявно создаёт новую анонимную
структуру для хранения захваченных переменных, тем временем реализуя
функциональность для некого неизвестного типа с помощью одного из типажей: <code>Fn</code>,
<code>FnMut</code>, или <code>FnOnce</code>. Этот тип присваивается переменной, которая хранится до
самого вызова замыкания.</p>
<p>Так как этот новый тип заранее неизвестен, любое его использование в функции
потребует обобщённых типов. Тем не менее, неограниченный параметр типа <code>&lt;T&gt;</code>
по прежнему будет неоднозначным и недопустим. Таким образом, ограничение по
одному из типажей: <code>Fn</code>, <code>FnMut</code>, или <code>FnOnce</code> (которые он реализует) необходимо
для использования этого типа.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `F` должен реализовать `Fn` для замыкания, которое
// ничего не принимает и не возвращает - именно то,
// что нужно для `print`.
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Захватываем `x` в анонимный тип и реализуем
    // `Fn` для него. Сохраняем его как `print`.
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-24" id="Смотрите-также-24">Смотрите также:</a></h3>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">Подробный разбор</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
и <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#Входные-функции" id="Входные-функции">Входные функции</a></h1>
<p>Так как замыкания могут использоваться в аргументах, вы можете ожидать, что то
же самое можно сказать и про функции. И это действительно так! Если вы
объявляете функцию, принимающую замыкание как аргумент, то любая функция,
удовлетворяющая ограничениям типажа этого замыкания, может быть передана как
аргумент.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Объявляем функцию, которая принимает обобщённый тип `F`,
// ограниченный типажом `Fn`, и вызывает его.
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// Объявляем функцию-обёртку, удовлетворяющую ограничению `Fn`
fn function() {
    println!(&quot;Я функция!&quot;);
}

fn main() {
    // Определяем замыкание, удовлетворяющее ограничению `Fn`
    let closure = || println!(&quot;Я замыкание!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>Стоит отметить, что типажи <code>Fn</code>, <code>FnMut</code> и <code>FnOnce</code> указывают, как
замыкание захватывает переменные из своей области видимости.</p>
<h3><a class="header" href="#Смотрите-также-25" id="Смотрите-также-25">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, и <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#Как-выходные-параметры" id="Как-выходные-параметры">Как выходные параметры</a></h1>
<p>Замыкания могут использоваться как входные параметры, следовательно их возврат в
качестве выходных параметров также должен быть возможен. Однако, это сопряжено
с трудностями из-за того, что Rust в настоящее время поддерживает только возврат
конкретных (не обобщённых) типов. Типы анонимных замыканий, по определению,
неизвестны. И поэтому возвращение замыканий возможно только путём конкретизации
их типов. Это можно реализовать упаковав замыкание.</p>
<p>Возможные типажи для возвращаемых значений немного отличаются от прежних:</p>
<ul>
<li><code>Fn</code>: как раньше</li>
<li><code>FnMut</code>: как раньше</li>
<li><code>FnOnce</code>: здесь присутствуют некоторые неожиданности, поэтому необходим тип<a href="https://doc.rust-lang.org/std/boxed/trait.FnBox.html"><code>FnBox</code></a>, но он нестабилен в настоящее время. В будущем ожидаютсяизменения этой ситуации.</li>
</ul>
<p>Помимо этого, должно быть использовано ключевое слово <code>move</code>, чтобы
сигнализировать о том, что все переменные захватываются по значению. Это
необходимо, так как любые захваченные по ссылке значения будут удалены после
выхода из функции, оставляя недопустимые ссылки в замыкании.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn create_fn() -&gt; Box&lt;Fn()&gt; {
    let text = &quot;Fn&quot;.to_owned();

    Box::new(move || println!(&quot;Это a: {}&quot;, text))
}

fn create_fnmut() -&gt; Box&lt;FnMut()&gt; {
    let text = &quot;FnMut&quot;.to_owned();

    Box::new(move || println!(&quot;Это a: {}&quot;, text))
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();

    fn_plain();
    fn_mut();
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-26" id="Смотрите-также-26">Смотрите также:</a></h3>
<p><a href="fn/closures/../../std/box.html">Упаковка</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, и <a href="fn/closures/../../generics.html">Обобщения</a>.</p>
<h1><a class="header" href="#Примеры-из-библиотеки-std" id="Примеры-из-библиотеки-std">Примеры из библиотеки <code>std</code></a></h1>
<p>Этот раздел содержит несколько примеров использования замыканий из библиотеки <code>std</code>.</p>
<h1><a class="header" href="#iteratorany" id="iteratorany">Iterator::any</a></h1>
<p><code>Iterator::any</code> - это функция, которая принимает итератор и возвращает <code>true</code>,
если любой элемент удовлетворяет предикату. Иначе возвращает <code>false</code>. Её
объявление:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // Тип, по которому выполняется итерирование
    type Item;

    // `any` принимает `&amp;mut self`, что означает заимствование
    // и изменение, но не поглощение `self`.
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` означает, что любая захваченная переменная
        // может быть изменена, но не поглощена. `Self::Item`
        // указывает на захват аргументов замыкания по значению.
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` для векторов даёт `&amp;i32`. Приводим к `i32`.
    println!(&quot;2 в vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` для векторов даёт `i32`. Приведения не требуется.
    println!(&quot;2 в vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` для массивов даёт `&amp;i32`.
    println!(&quot;2 в array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` для массивов неожиданно даёт `&amp;i32`.
    println!(&quot;2 в array2: {}&quot;, array2.into_iter().any(|&amp;x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-27" id="Смотрите-также-27">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<h1><a class="header" href="#iteratorfind" id="iteratorfind">Iterator::find</a></h1>
<p><code>Iterator::find</code> - это функция, которая принимает итератор и возвращает первый
элемент, который удовлетворяет предикату, в виде <code>Option</code>. Её объявление:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // Тип, по которому выполняется итерирование
    type Item;

    // `find` принимает `&amp;mut self`, что означает заимствование и
    // изменение, но не поглощение `self`.
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` означает, что любая захваченная переменная
        // может быть изменена, но не поглощена. `&amp;Self::Item`
        // указывает на захват аргументов замыкания по ссылке.
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` для векторов даёт `&amp;i32`.
    let mut iter = vec1.iter();
    // `into_iter()` для векторов даёт `i32`.
    let mut into_iter = vec2.into_iter();

    // Ссылка на это даёт `&amp;&amp;i32`. Приводим к `i32`.
    println!(&quot;Найти 2 в vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // Ссылка на это даёт `&amp;i32`. Приводим к `i32`.
    println!(&quot;Найти 2 в vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` для массивов даёт `&amp;i32`
    println!(&quot;Найти 2 в array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // `into_iter()` для массивов неожиданно даёт `&amp;i32`
    println!(&quot;Найти 2 в array2: {:?}&quot;, array2.into_iter().find(|&amp;&amp;x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-28" id="Смотрите-также-28">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<h1><a class="header" href="#Функции-высшего-порядка" id="Функции-высшего-порядка">Функции высшего порядка</a></h1>
<p>Rust предоставляет Функций Высшего Порядка(ФВП). Это функций которые берут один или
больше функций и производит более полезные функций.
ФВП и ленивые итераторы дают языку Rust функциональную особенность.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Найти сумму всех квадратов нечётных числ не больше 1000&quot;);
    let upper = 1000;

    // Императивный подход
    // Объявляем переменную накопитель
    let mut acc = 0;
    // Итерировать: 0, 1, 2, ... до бесконечности
    for n in 0.. {
        // Квадрат числа
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // Остановить цикл, если превысили верхний лимит
            break;
        } else if is_odd(n_squared) {
            // Складывать число, если оно нечётное
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);

    // Функциональный подход
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)             // Все натуральные числа в квадрате
             .take_while(|&amp;n| n &lt; upper) // Ниже верхнего предела
             .filter(|n| is_odd(*n))     // Это нечётные
             .fold(0, |sum, i| sum + i); // Суммируем
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/core/option/enum.Option.html">Option</a>
и
<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a>
реализуют свою часть функций высшего порядка..</p>
<h1><a class="header" href="#diverging-functions" id="diverging-functions">Diverging functions</a></h1>
<p>Diverging functions never return. They are marked using <code>!</code>, which is an empty type.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() -&gt; ! {
    panic!(&quot;This call never returns.&quot;);
}
#}</code></pre></pre>
<p>As opposed to all the other types, this one cannot be instantiated, because the
set of all possible values this type can have is empty. Note, that it is
different from the <code>()</code> type, which has exactly one possible value.</p>
<p>For example, this functions returns as usual, although there is no information
in the return value.</p>
<pre><pre class="playpen"><code class="language-rust">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;This functions returns and you can see this line.&quot;)
}
</code></pre></pre>
<p>As opposed to this function, which will never return the control back to the caller.</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;This call never returns.&quot;);
    println!(&quot;You will never see this line!&quot;);
}
</code></pre>
<p>Although this might seem like an abstract concept, it is in fact very useful and
often handy. The main advantage of this type is that it can be cast to any other
one and therefore used at places where an exact type is required, for instance
in <code>match</code> branches. This allows us to write code like this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // Notice that the return type of this match expression must be u32
            // because of the type of the &quot;addition&quot; variable.
            let addition: u32 = match i%2 == 1 {
                // The &quot;i&quot; variable is of type u32, which is perfectly fine.
                true =&gt; i,
                // On the other hand, the &quot;continue&quot; expression does not return
                // u32, but it is still fine, because it never returns and therefore
                // does not violate the type requirements of the match expression.
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Sum of odd numbers up to 9 (excluding): {}&quot;, sum_odd_numbers(9));
}
</code></pre></pre>
<p>It is also the return type of functions that loop forever (e.g. <code>loop {}</code>) like
network servers or functions that terminates the process (e.g. <code>exit()</code>).</p>
<h1><a class="header" href="#Модули" id="Модули">Модули</a></h1>
<p>Rust предоставляет мощную систему модулей, которая используется,
чтобы иерархически разделить код на логические единицы (модули) и
управлять видимостью (публичное и приватное) между ними.</p>
<p>Модуль это набор элементов, таких как: функции, структуры, типажи, блоки реализации
и даже другие модули.</p>
<h1><a class="header" href="#Видимость" id="Видимость">Видимость</a></h1>
<p>По умолчанию, элементы модуля являются приватными,
но это можно изменить добавив модификатор <code>pub</code>.
Только публичные элементы модуля могут быть доступны за пределами его области видимости.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Модуль по имени `my_mod`
mod my_mod {
    // Все элементы модуля по умолчанию являются приватными.
    fn private_function() {
        println!(&quot;вызвана `my_mod::private_function()`&quot;);
    }

    // Используем модификатор `pub`, чтобы сделать элемент публичным.
    pub fn function() {
        println!(&quot;вызвана `my_mod::function()`&quot;);
    }

    // Приватные элементы модуля доступны другим элементам
    // данного модуля.
    pub fn indirect_access() {
        print!(&quot;вызвана `my_mod::indirect_access()`, которая\n&gt; &quot;);
        private_function();
    }

    // Модули так же могут быть вложенными
    pub mod nested {
        pub fn function() {
            println!(&quot;вызвана `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;вызвана `my_mod::nested::private_function()`&quot;);
        }

        // Функции объявленные с использованием синтаксиса `pub(in path)` будет видна
        // только в пределах заданного пути.
        // `path` должен быть родительским или наследуемым модулем
        pub(in my_mod) fn public_function_in_my_mod() {
            print!(&quot;вызвана `my_mod::nested::public_function_in_my_mod()`, которая\n &gt; &quot;);
            public_function_in_nested()
        }

        // Функции объявленные с использованием синтаксиса `pub(self)` будет видна
        // только в текущем модуле
        pub(self) fn public_function_in_nested() {
            println!(&quot;вызвана `my_mod::nested::public_function_in_nested&quot;);
        }

        // Функции объявленные с использованием синтаксиса `pub(super)` будет видна
        // только в родительском модуле
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;вызвана my_mod::nested::public_function_in_super_mod&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;вызвана `my_mod::call_public_funcion_in_my_mod()`, которая\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // pub(crate) сделает функцию видимой для всего текущего контейнера
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()&quot;);
    }

    // Вложенные модули подчиняются тем же правилам видимости
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;вызвана `my_mod::private_nested::function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;вызвана `function()`&quot;);
}

fn main() {
    // Модули позволяют устранить противоречия между элементами,
    // которые имеют одинаковые названия.
    function();
    my_mod::function();

    // Публичные элементы, включая те, что находятся во вложенном модуле,
    // доступны извне родительского модуля
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) элементы можно вызвать от везде в этом же пакете
    my_mod::public_function_in_crate();
    
    // pub(in path) элементы могут вызываться только для указанного пути
    // Ошибка! функция `public_function_in_my_mod` приватная
    //my_mod::nested::public_function_in_my_mod();
    // TODO ^ Попробуйте раскомментировать эту строку

    // Приватные элементы модуля не доступны напрямую,
    // даже если вложенный модуль является публичным:

    // Ошибка! функция `private_function` приватная
    //my_mod::private_function();
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Ошибка! функция `private_function` приватная
    //my_modmy::nested::private_function();
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Ошибка! Модуль `private_nested` является приватным
    //my_mod::private_nested::function();
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку
}
</code></pre></pre>
<h1><a class="header" href="#Видимость-структуры" id="Видимость-структуры">Видимость структуры</a></h1>
<p>Структуры имеют дополнительный уровень видимости благодаря полями. По умолчанию
видимость полей приватная, но, это можно изменить с помощью модификатора <code>pub</code>.
Приватная видимость имеет значение только при обращении к структуре извне модуля,
где она определена, и необходимо скрыть информацию (инкапсуляция).</p>
<pre><pre class="playpen"><code class="language-rust editable">mod my {
   // Публичная структура с публичным полем обобщённого типа `T`
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // Публичная структура с приватным полем обобщённого типа `T`
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // Публичный конструктор
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // Публичная структура с публичным полем может быть создана, как обычно
    let open_box = my::OpenBox { contents: &quot;публичную информацию&quot; };

    // а их поля доступны всем.
    println!(&quot;Открытая упаковка хранит: {}&quot;, open_box.contents);

    // Публичные структуры с приватными полями не могут быть созданы, используя имя полей
    // Ошибка! `ClosedBox` имеет приватные поля
    //let closed_box = my::ClosedBox { contents: &quot;классифицированную информацию&quot; };
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Однако, структуры с приватными полями могут быть созданы с помощью
    // публичного конструктора
    let _closed_box = my::ClosedBox::new(&quot;классифицированную информацию&quot;);

    // нельзя получить доступ к приватным полям публичных структур.
    // Ошибка! Поле `contents` приватное
    //println!(&quot;Закрытая упаковка хранит: {}&quot;, _closed_box.contents);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-29" id="Смотрите-также-29">Смотрите также:</a></h3>
<p><a href="mod/generics.html">generics</a> и <a href="mod/fn/methods.html">методы</a></p>
<h1><a class="header" href="#Декларация-use-1" id="Декларация-use-1">Декларация <code>use</code></a></h1>
<p>Декларация <code>use</code> используется, чтобы связать полный путь с новым именем,
что упрощает доступ.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Привязать путь `deeply::nested::function` к `other_function`.
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;вызвана `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;вызвана `deeply::nested::function()`&quot;)
        }
    }
}

fn main() {
    // Упрощённый доступ к `deeply::nested::function`
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // Эквивалентно `use deeply::nested::function as function`.
        // `function()` затенение собой внешнюю функцию.
        use deeply::nested::function;
        function();

        // у привязок `use` локальная область видимости. В данном случае
        // внешняя `function()` затенена только в этом блоке.
        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<h1><a class="header" href="#super-и-self" id="super-и-self"><code>super</code> и <code>self</code></a></h1>
<p>Ключевые слова <code>super</code> и <code>self</code> в пути используются, 
чтобы устранить неоднозначность между используемыми элементами модуля.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn function() {
    println!(&quot;вызвана `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;вызвана `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;вызвана `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // Давайте вызовем  все функции под названием `function` в этой области видимости!
        print!(&quot;вызвана `my::indirect_call()`, с помощью которой\n&gt; &quot;);
        
        // Ключевое слово `self` ссылается на область видимости текущего модуля. 
        // В нашем случае - модуль `my`.
        // Вызов `self::function()`, так же как и вызов `function()` дают одинаковый результат,
        // т.к они ссылаются на одну и ту же функцию.
        self::function();
        function();
        
        // Мы так же можем использовать ключевое слово `self`,
        // чтобы получить доступ к другим модулям внутри модуля `my`:
        self::cool::function();
        
        // Ключевое слово `super` ссылается на родительскую область видимости (вне модуля `my`).
        super::function();
        
        // Этим действием мы свяжем `cool::function` в области видимости *контейнера*.
        // В данном случае область видимости контейнера является самой дальней областью видимости.
        {
            use cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<h1><a class="header" href="#Иерархия-файлов" id="Иерархия-файлов">Иерархия файлов</a></h1>
<p>Модули могут быть отображены на иерархию файлов и директорий.
Давайте разобьём <a href="mod/mod/visibility.html">пример с видимостью модулей</a> на файлы:</p>
<pre><code class="language-bash">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p>В <code>split.rs</code>:</p>
<pre><code class="language-rust ignore">// Эта декларация найдёт файл с именем `my.rs` или `my/mod.rs` и вставит
// его содержимое внутрь модуля с именем `my` в этой области видимости
mod my;

fn function() {
    println!(&quot;вызвана `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}

</code></pre>
<p>В <code>my/mod.rs</code>:</p>
<pre><code class="language-rust ignore">// Точно так же, `mod inaccessible` и `mod nested` обнаружат файлы `nested.rs`
// и `inaccessible.rs`, и затем вставят их здесь в соответствующие модули

mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;вызвана `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;вызывает `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;вызвана `my::indirect_access()`, которая\n&gt; &quot;);

    private_function();
}
</code></pre>
<p>В <code>my/nested.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;вызвана `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;вызвана `my::nested::private_function()`&quot;);
}
</code></pre>
<p>В <code>my/inaccessible.rs</code>:</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;вызвана `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<p>Давайте проверим, что все ещё работает, как раньше:</p>
<pre><code class="language-bash">$ rustc split.rs &amp;&amp; ./split
вызвана `my::function()`
вызвана `function()`
вызвана `my::indirect_access()`, которая
&gt; вызвана `my::private_function()`
вызвана `my::nested::function()`
</code></pre>
<h1><a class="header" href="#Контейнеры" id="Контейнеры">Контейнеры</a></h1>
<p>Контейнер (<code>crate</code>) — единица компиляции в языке Rust.
Когда вызывается <code>rustc some_file.rs</code>, <code>some_file.rs</code> обрабатывается как <em>файл контейнера</em>.
Если в <code>some_file.rs</code> есть декларация <code>mod</code>, то содержимое модуля
будет объединено с файлом контейнера <em>перед</em> его компиляцией.
Другими словами, модули <em>не</em> собираются отдельно, собираются лишь контейнеры.</p>
<p>Контейнер может быть скомпилирован в исполняемый файл или в библиотеку.
По умолчанию, <code>rustc</code> создаёт исполняемый файл из контейнера.
Это поведение может быть изменено добавлением флага <code>--crate-type</code> к <code>rustc</code>.</p>
<h1><a class="header" href="#Библиотеки" id="Библиотеки">Библиотеки</a></h1>
<p>Давайте создадим библиотеку и посмотрим, как связать её с другим контейнером.</p>
<pre><code class="language-rust ignore">pub fn public_function() {
    println!(&quot;вызвана `public_function()` библиотеки rary&quot;);
}

fn private_function() {
    println!(&quot;вызвана `private_function()` библиотеки rary&quot;);
}

pub fn indirect_access() {
    print!(&quot;вызвана `indirect_access()` библиотеки rary, и в ней\n&gt; &quot;);

    private_function();
}
</code></pre>
<pre><code class="language-bash">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>Библиотеки получают префикс «lib», и по умолчанию имеют то же имя,
что и их контейнеры, но это имя можно изменить
с помощью <a href="crates/attribute/crate.html">атрибута <code>crate_name</code></a>.</p>
<h1><a class="header" href="#extern-crate" id="extern-crate"><code>extern crate</code></a></h1>
<p>Чтобы связать контейнер с новой библиотекой, нужна декларация <code>extern crate</code>.
Она не только свяжет библиотеку, но и импортирует все элементы в модуль
с тем же именем, что и сама библиотека.
Правила видимости, применимые к модулям, так же применимы и к библиотекам.</p>
<pre><code class="language-rust ignore">// Ссылка на `library`. Импортируем элементы, как модуль `rary`
extern crate rary;

fn main() {
    rary::public_function();

    // Ошибка! Функция `private_function` приватная
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-bash"># Где library.rlib путь к скомпилированной библиотеке. Предположим, что
# она находится в той же директории:
$ rustc executable.rs --extern rary=library.rlib &amp;&amp; ./executable
вызвана `public_function()` библиотеки rary
вызвана `indirect_access()` библиотеки rary, и в ней
&gt; вызвана `private_function()` библиотеки rary
</code></pre>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<p><code>cargo</code> - официальный менеджер пакетов языка Rust. В нем много функций
для улучшения качества кода и увеличения скорости разработки! К ним относятся:</p>
<ul>
<li>Управление зависимостями и интеграция с <a href="https://crates.io">crates.io</a> (официальный реестр пакетов Rust)</li>
<li>Осведомленность о модульных тестах</li>
<li>Осведомленность о тестах производительности</li>
</ul>
<p>Эта глава рассказывает об основах, но вы можете найти полное описание
по адресу <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a>.</p>
<h1><a class="header" href="#Зависимости" id="Зависимости">Зависимости</a></h1>
<p>Большинство программ зависят от нескольких библиотек. Если вам приходилось
когда-либо управлять зависимостями вручную, вы знаете, сколько боли это
может доставить. К счастью экосистема языка Rust содержит такой
инструмент как <code>cargo</code>! <code>cargo</code> может управлять зависимостями проекта.</p>
<p>Создание нового проекта на языке Rust:</p>
<pre><code class="language-sh"># Исполняемый проект (проект с программой)
cargo new foo

# ИЛИ библиотека
cargo new --lib foo
</code></pre>
<p>Для остальной части этой главы предполагается, что мы делаем двоичный файл, а не
библиотеку, но все понятия одинаковы.</p>
<p>После приведённых выше команд, вы должны увидеть что-то вроде этого:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p><code>main.rs</code> - это корневой файл вашего нового проекта.
<code>Cargo.toml</code> - это конфигурационный файл этого проекта (<code>foo</code>) для <code>cargo</code>.
Если посмотрите внутрь файла, вы должны увидеть что-то вроде этого:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<p>Поле <code>name</code> под <code>package</code> определяет имя проекта. Оно используется
если Вы будете его публиковать на <code>crates.io</code> (более подробно позже).
Также это имя выходного файла при компиляции.</p>
<p>Поле <code>version</code> - это версия пакета, записанное с использованием системы
<a href="http://semver.org/">семантического версионирования</a>.</p>
<p>Поле <code>authors</code> содержит список авторов пакета и используется при публикации.</p>
<p>В секции <code>dependencies</code> Вы можете указывать зависимости вашего проекта.</p>
<p>Предположим, что вы хотите, чтобы ваша программа имела отличный CLI.
Вы можете найти много хороших пакетов на <a href="https://crates.io">crates.io</a><a href="https://crates.io">(официальный реестр пакетов языка Rust). Один из популярных вариантов - </a><a href="https://crates.io/crates/clap">clap</a>. На момент написания этой статьи
самой последней опубликованной версией <code>clap</code> является <code>2.27.1</code>.
Для добавления зависимости в ваш проект, вы можете просто добавить
соответствующую запись в Ваш <code>Cargo.toml</code> под <code>dependencies</code>: <code>clap = &quot;2.27.1&quot;</code>.
И конечно, <code>extern crate clap</code> в <code>main.rs</code>. И это все! Вы можете начать
использовать <code>clap</code> в вашей программе.</p>
<p><code>cargo</code> также поддерживает <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">другие типы зависимостей</a>. Здесь только
небольшие примеры:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # из crates.io
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # из онлайн репозитория
bar = { path = &quot;../bar&quot; } # из локальной файловой системы
</code></pre>
<p><code>cargo</code> больше чем менеджер зависимостей. Все поддерживаемые возможности доступны
в <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">спецификации формата</a> <code>Cargo.toml</code>.</p>
<p>Для сборки проекта Вы можете выполнить команду <code>cargo build</code> в любой директории проекта
(включая поддиректории!). Также Вы можете выполнить <code>cargo run</code> для сборки и запуска.
Обратите внимание, что эти команды разрешат все зависимости, скачают пакеты
если нужно, и соберут все, включая ваш пакет. (Обратите внимание, что он собирает только то,
что ещё не собрал, подобно <code>make</code>).</p>
<p>Вот и все!</p>
<h1><a class="header" href="#Соглашения" id="Соглашения">Соглашения</a></h1>
<p>В предыдущей главе мы видели следующую иерархию каталогов:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>Предположим, что мы хотим иметь два двоичных файла в одном проекте. Что
тогда?</p>
<p>Оказывается, <code>cargo</code> это поддерживает. Двоичный файл по умолчанию называется <code>main.rs</code>,
это мы видели раньше, но вы можете добавить дополнительные файлы, поместив
их в каталог <code>bin/</code>:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p>Чтобы сказать <code>cargo</code> скомпилировать или запустить этот двоичный файл,
мы просто передаём <code>cargo</code> флаг <code>--bin my_other_bin</code>, где <code>my_other_bin</code>
это имя двоичного файла, с которым мы хотим работать.</p>
<p>Помимо дополнительных двоичных файлов, в <code>cargo</code> есть
<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">встроенная поддержка</a> примеров, модульных тестов,
интеграционных тестов и тестов на производительность.</p>
<p>В следующей главе мы более подробно рассмотрим тесты.</p>
<h1><a class="header" href="#Тестирование" id="Тестирование">Тестирование</a></h1>
<p>Как мы знаем, тестирование является неотъемлемой частью любого программного обеспечения! Rust имеет первоклассную поддержку модульного и интеграционного тестирования (см.
<a href="https://doc.rust-lang.org/book/ch11-00-testing.html">главу о тестировании в TRPL</a>).</p>
<p>Из разделов тестирования, приведённых выше, мы знаем, как писать модульные и интеграционные тесты. Организационно, мы можем расположить модульные тесты в модулях, которые они тестируют, а интеграционные - в собственном каталоге <code>tests/</code>:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p>Каждый файл в каталоге <code>tests</code> - это отдельный интеграционный тест.</p>
<p><code>cargo</code>  естественно, обеспечивает простой способ запуска всех ваших тестов!</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>Вы должны увидеть примерно такой результат:</p>
<pre><code class="language-txt">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Вы также можете запустить тесты, чьё имя соответствует шаблону:</p>
<pre><code class="language-sh">cargo test test_foo
</code></pre>
<pre><code class="language-txt">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>Одно слово предостережения: Cargo может выполнять несколько тестов одновременно, поэтому убедитесь, что они не участвуют в гонках друг с другом. Например, если они все выводят в файл, вы должны заставить их записывать в разные файлы.</p>
<h1><a class="header" href="#Атрибуты" id="Атрибуты">Атрибуты</a></h1>
<p>Атрибуты - это метаданные, применяемые к какому-либо модулю, контейнеру или их элементу.
Благодаря атрибутам можно:</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="attribute/cfg.html">задать условия компиляции кода</a></li>
<li><a href="attribute/crate.html">задать имя, версию и тип (библиотека или исполняемый файл) контейнера</a></li>
<li>отключить <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">lints</a> (предупреждения)</li>
<li>включить возможности компилятора (макросы, глобальный импорт и другое.)</li>
<li>связаться с внешней библиотекой</li>
<li>пометить функции как юнит тесты</li>
<li>пометить функции, которые будут частью бенчмарка</li>
</ul>
<p>Когда атрибуты применяются ко всему контейнеру, их синтаксис будет #![crate_attribute],
когда они применяются к модулю или элементу модуля,
их синтаксис станет #[item_attribute] (обратите внимание на отсутствие !).</p>
<p>Атрибуты могут принимать аргументы с различным синтаксисом:</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>Атрибуты могут иметь несколько значений и могут быть разделены несколькими строками:</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]


#[attribute(value, value2, value3,
            value4, value5)]
</code></pre>
<h1><a class="header" href="#dead_code" id="dead_code"><code>dead_code</code></a></h1>
<p>Компилятор предоставляет <a href="https://en.wikipedia.org/wiki/Lint_%28software%29"><em>проверку</em></a> <code>dead_code</code>,
которая предупреждает о неиспользованных функциях. Атрибут <em>dead_code</em> можно использовать, чтобы отключить данную проверку.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn used_function() {}

// `#[allow(dead_code)]` - атрибут, который убирает проверку на неиспользуемый код
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// ИСПРАВЬТЕ ^ Добавьте атрибут `dead_code`, чтобы убрать предупреждение

fn main() {
    used_function();
}
</code></pre></pre>
<p>Обратите внимание, что в реальных программах, вы должны удалить неиспользуемый код.
В этих примерах мы разрешаем оставить неиспользуемый код в некоторых местах,
но, это только для примера!</p>
<h1><a class="header" href="#Контейнеры-1" id="Контейнеры-1">Контейнеры</a></h1>
<p>Атрибут <code>crate_type</code> используется, чтобы сказать компилятору,
какой контейнер является библиотекой (и каким типом библиотеки),
а какой исполняемым файлом. Атрибут <code>crate_name</code> используется для указания имени контейнера.</p>
<p>Однако важно отметить, что атрибуты <code>crate_type</code> и <code>create_name</code> <strong>не имеют значения</strong> при использовании пакетного менеджера Cargo.
В виду того, что Cargo используется для большинства проектов на Rust,
это значит в реальном мире использование <code>crate_type</code> и <code>crate_name</code>
достаточно ограничено.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Этот контейнер - библиотека
#![crate_type = &quot;lib&quot;]
// Эта библиотека называется &quot;rary&quot;
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;вызвана `public_function()` библиотеки `rary`&quot;);
}

fn private_function() {
    println!(&quot;вызвана `private_function()` библиотеки `rary`&quot;);
}

pub fn indirect_access() {
    print!(&quot;вызвана `indirect_access()` библиотеки `rary`, и в ней\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<p>Если мы используем атрибут <code>crate_type</code>,
то нам больше нет необходимости передавать флаг <code>--crate-type</code> компилятору.</p>
<pre><code class="language-bash">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<h1><a class="header" href="#cfg" id="cfg"><code>cfg</code></a></h1>
<p>Условная компиляция возможна благодаря двум операторам:</p>
<ul>
<li>Атрибуту <code>cfg</code>: <code>#[cfg(...)]</code>, который указывается на месте атрибута</li>
<li>Макросу <code>cfg!</code>: <code>cfg!(...)</code>, который можно использовать в условных выражениях</li>
</ul>
<p>Оба имеют идентичный синтаксис для принятия аргументов.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Эта функция будет скомпилирована только в том случае, если целевая ОС будет linux
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;Вы работаете в linux!&quot;);
}

// А эта функция будет скомпилирована, если целевая ОС *не* linux
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;Вы работаете *не* в linux!&quot;);
}

fn main() {
    are_you_on_linux();
    
    println!(&quot;Вы уверены?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Да. Это точно linux!&quot;);
    } else {
        println!(&quot;Да. Это точно *не* linux!&quot;);
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-30" id="Смотрите-также-30">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">the reference</a>, <a href="https://doc.rust-lang.org/std/macro.cfg!.html"><code>cfg!</code></a>, и <a href="attribute/macros.html">macros</a>.</p>
<h1><a class="header" href="#Собственные-условия" id="Собственные-условия">Собственные условия</a></h1>
<p>Некоторые условия, например, <code>target_os</code> предоставляются компилятором.
Если мы хотим создать собственные условия, 
то их необходимо передать компилятору используя флаг <code>--cfg</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;);
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>Попробуйте запустить без указания флага <code>cfg</code>.</p>
<p>С указанием флага <code>cfg</code>:</p>
<pre><code class="language-bash">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<h1><a class="header" href="#Обобщения" id="Обобщения">Обобщения</a></h1>
<p><em>Обобщения</em> позволяют генерализировать типы и функционал для более общих случаев. Они
чрезвычайно полезны благодаря уменьшению дублирования кода, однако могут привести к
сравнительному усложнению синтаксиса. А именно, использование обобщений требует особого
внимания при определении допустимых реальных типов которыми могут заменяться обобщённые.
Наиболее простым и распространённым применением обобщений является обобщение параметров
типа.</p>
<p>Обобщить параметр типа можно используя угловые скобки и верхний <a href="https://en.wikipedia.org/wiki/CamelCase">верблюжий регистр</a>:
<code>&lt;Aaa, Bbb, ...&gt;</code>. &quot;Обобщённые параметры типа&quot; обычно представлены как <code>&lt;T&gt;</code>. В Rust,
&quot;обобщённым&quot; также принято называть все, что может принимать один или более обобщённых
параметров типа <code>&lt;T&gt;</code>. Любой тип, указанный в качестве параметра обобщённого типа,
является обобщённым, а всё остальное является конкретным (не обобщённым).</p>
<p>Например, объявление <em>обобщённой функции</em> <code>foo</code> принимающей аргумент <code>T</code> любого типа:</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<p>Поскольку <code>T</code> был объявлен как обобщённый тип, посредством <code>&lt;T&gt;</code>, он считается обобщённым
когда используется как <code>(arg: T)</code>. Это работает даже если <code>T</code> был определён как [структура]
<a href="custom_types/structs.html">structs</a>.</p>
<p>Пример ниже демонстрирует синтаксис в действии:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A concrete type `A`.
// Конкретный тип `A`.
struct A;

// В определении типа `Single` первому использованию `A` не предшествует `&lt;A&gt;`.
// Поэтому `Single` имеет конкретный тип, и `A` определена выше.
struct Single(A);
//            ^ Здесь `A` в первый раз используется в `Single`.

// В данном примере, `&lt;T&gt;` предшествует первому использованию `T`,
// поэтому `SingleGen` является обобщённым типом.
// Поскольку тип параметра `T` является обобщённым, он может быть чем угодно, включая
// конкретный тип `A`, определённый выше.
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` имеет конкретный тип и явно принимает параметр `A`.
    let _s = Single(A);

    // Создаём переменную `_char` типа `SingleGen&lt;char&gt;`
    // и присваиваем ей значение `SingleGen('a')`.
    // В примере ниже, тип параметра `SingleGen` явно определён.
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // Здесь, `SingleGen` также может иметь неявно определённый параметр типа:
    let _t    = SingleGen(A); // Используется структура `A`, объявленная выше.
    let _i32  = SingleGen(6); // Используется `i32`.
    let _char = SingleGen('a'); // Используется `char`.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-31" id="Смотрите-также-31">Смотрите также:</a></h3>
<p><a href="custom_types/structs.html">Структуры</a></p>
<h1><a class="header" href="#Функции-1" id="Функции-1">Функции</a></h1>
<p>Тот же набор правил применяется и к функциям: тип <code>T</code> становится
обобщённым, когда предшествует <code>&lt;T&gt;</code>.</p>
<p>При использовании обобщённых функций, иногда требуется явно указывать тип
данных параметров. Это может быть необходимо в случае, если вызываемая функция возвращает
обобщённый тип или у компилятора недостаточно информации для вывода необходимого
типа данных.</p>
<p>Вызов функции с явно указанными типами данных параметров выглядит так:
<code>fun::&lt;A, B, ...&gt;()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct A; // Конкретный тип `A`.
struct S(A); // Конкретный тип `S`.
struct SGen&lt;T&gt;(T); // Обобщённый тип `SGen`.

// Все следующие функции становятся владельцем переменной, переданной в них.
// После передачи, она сразу выходит из области видимости и освобождается.

// Объявляем функцию `reg_fn`, которая принимает аргумент `_s` типа `S`.
// Здесь отсутствует `&lt;T&gt;`, поэтому это не обобщённая функция.
fn reg_fn(_s: S) {}

// Объявляем функцию `gen_spec_t`, которая принимает аргумент `_s` типа `SGen&lt;T&gt;`.
// В ней явно задан параметр типа `A`, но поскольку `A` не был указан
// как параметр обобщённого типа для `gen_spec_t`, то он не является обобщённым.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// Объявляем функцию `gen_spec_i32`, которая принимает аргумент `_s` типа `SGen&lt;i32&gt;`.
// В ней явно задан тип `i32`, который является определённым типом.
// Поскольку `i32` не является обобщённым типом, эта функция
// также не является обобщённой.
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// Объявляем функцию `generic`, которая принимает аргумент `_s` типа `SGen&lt;T&gt;`.
// Поскольку `SGen&lt;T&gt;` предшествует `&lt;T&gt;`, эта функция
// является обобщённой над `T`.
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Используем не обобщённые функции.
    reg_fn(S(A)); // Конкретный тип.
    gen_spec_t(SGen(A)); // Неявно определён тип параметра `A`.
    gen_spec_i32(SGen(6)); // Неявно определён тип параметра `i32`.

    // Явно определён тип параметра `char` в `generic()`.
    generic::&lt;char&gt;(SGen('a'));

    // Неявно определён параметр типа `char` в `generic()`.
    generic(SGen('c'));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-32" id="Смотрите-также-32">Смотрите также:</a></h3>
<p><a href="generics/fn.html">Функции</a> и <a href="generics/custom_types/structs.html">структуры</a></p>
<h1><a class="header" href="#Реализация" id="Реализация">Реализация</a></h1>
<p>Подобно функциям, реализации требуют выполнения некоторых условий, чтобы оставаться обобщёнными.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct S; // Конкретный тип `S`
struct GenericVal&lt;T&gt;(T,); // Обобщенный тип `GenericVal`

// Реализация GenericVal, где мы явно указываем типы данных параметров:
impl GenericVal&lt;f32&gt; {} // Указываем тип `f32`
impl GenericVal&lt;S&gt; {} // Указываем тип `S`, который мы определили выше

// `&lt;T&gt;` Должен указываться перед типом, чтобы оставаться обобщенным
impl &lt;T&gt; GenericVal&lt;T&gt; {}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">struct Val {
    val: f64
}

struct GenVal&lt;T&gt;{
    gen_val: T
}

// Реализация Val
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 { &amp;self.val }
}

// Реализация GenVal для обобщённого типа `T`
impl &lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T { &amp;self.gen_val }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };

    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-33" id="Смотрите-также-33">Смотрите также:</a></h3>
<p><a href="generics/scope/lifetime/fn.html">functions returning references</a>, <a href="generics/fn/methods.html"><code>impl</code></a>, and <a href="generics/custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#Типажи" id="Типажи">Типажи</a></h1>
<p>Конечно <code>типажи</code> тоже могут быть обобщёнными. Здесь мы определяем, тот
который повторно реализует <code>типаж</code> <code>Drop</code> как обобщённый метод, чтобы
удалить себя и входные данные.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Некопируемые типы.
struct Empty;
struct Null;

// Обобщённый типаж от `T`.
trait DoubleDrop&lt;T&gt; {
    // Определим метод для типа вызывающего объекта,
    // который принимает один дополнительный параметр `T` и ничего с ним не делает.
    fn double_drop(self, _: T);
}

// Реализация `DoubleDrop&lt;T&gt;` для любого общего параметра `T` и
// вызывающего объекта `U`.
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // Этот метод получает право владения на оба переданных аргумента и
    // освобождает их.
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Освободить `empty` и `null`.
    empty.double_drop(null);

    //empty;
    //null;
    // ^ TODO: Попробуйте раскомментировать эти строки.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-34" id="Смотрите-также-34">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="generics/custom_types/structs.html"><code>Структуры</code></a>, и <a href="generics/trait.html"><code>Типажи</code></a></p>
<h1><a class="header" href="#Ограничения" id="Ограничения">Ограничения</a></h1>
<p>При работе с обобщениями параметры типа часто должны использовать типажи
в качестве <em>ограничений</em>, чтобы определить какие функциональные возможности
реализует тип. Например, в следующем примере для печати используется
типаж <code>Display</code> и поэтому требуется <code>T</code> ограничить по <code>Display</code>.
Это значит что <code>T</code> <em>должен</em> реализовать <code>Display</code>.</p>
<pre><code class="language-rust ignore">// Определим функцию `printer`, которая принимает обобщённый тип `T`,
// который должен реализовать типаж `Display`
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<p>Ограничение сужает список типов, допустимых к использованию. То есть:</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// Ошибка! `Vec&lt;T&gt;` не реализует `Display`. Эта
// специализация не удастся
let s = S(vec![1]);
</code></pre>
<p>Другой эффект ограничения заключается в том, что обобщённые экземпляры
имеют доступ к <a href="generics/fn/methods.html"><code>методам</code></a> типажей, указанных в ограничениях. Например:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Типаж, который реализует маркер печати: `{:?}`.
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// Обобщённый тип `T` должен реализовать `Debug`. Независимо
// от типа, это будет работать правильно.
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T` должен реализовать `HasArea`. Любая функция, которая удовлетворяет
// ограничению может получить доступ к функции `area` из `HasArea`.
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ TODO: Попробуйте раскомментировать эти строки.
    // | Ошибка: Не реализован `Debug` или `HasArea`.
}
</code></pre></pre>
<p>Утверждения <a href="generics/generics/where.html"><code>where</code></a> также могут использоваться для применения
ограничений в некоторых случаях, чтобы добавить выразительности.</p>
<h3><a class="header" href="#Смотрите-также-35" id="Смотрите-также-35">Смотрите также:</a></h3>
<p><a href="generics/hello/print.html"><code>std::fmt</code></a>, <a href="generics/custom_types/structs.html"><code>структуры</code></a>, и <a href="generics/trait.html"><code>типажи</code></a></p>
<h1><a class="header" href="#Пример-пустые-ограничения" id="Пример-пустые-ограничения">Пример: пустые ограничения</a></h1>
<p>Следствием того, как работают ограничения по типажу, является то,
что даже если <code>типаж</code> не включает в себя какие-либо функциональные
возможности, вы все равно можете использовать его в качестве ограничения.
Примерами таких типажей являются <code>Eq</code> и <code>Ord</code> из стандартной библиотеки.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// Эти функции действительны только для типов реализующих эти типажи.
// То, что типажи пусты, не имеет значения.
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;красная&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;синяя&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // `red()` не будет работать для blue_jay, ни наоборот,
    // из-за ограничений по типажу.
    println!(&quot;Кардинал {} птица&quot;, red(&amp;cardinal));
    println!(&quot;Голубая сойка {} птица&quot;, blue(&amp;blue_jay));
    //println!(&quot;Индюк {} птица&quot;, red(&amp;_turkey));
    // ^ TODO: Попробуйте раскомментировать эту строку.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-36" id="Смотрите-также-36">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>std::cmp::Ord</code>s</a>, и <a href="generics/bounds/trait.html"><code>типажи</code></a></p>
<h1><a class="header" href="#Множественные-ограничения" id="Множественные-ограничения">Множественные ограничения</a></h1>
<p>Множественные ограничения по типажу могут быть применены с помощью <code>+</code>.
Разные типы разделяются с помощью <code>,</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}&quot;, t);
    println!(&quot;u: `{:?}&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // ЗАДАНИЕ ^ Попробуйте удалить комментарий.

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-37" id="Смотрите-также-37">Смотрите также:</a></h3>
<p><a href="generics/hello/print.html"><code>std::fmt</code></a> и <a href="generics/trait.html"><code>типажи</code></a></p>
<h1><a class="header" href="#Утверждения-where" id="Утверждения-where">Утверждения where</a></h1>
<p>Ограничение типажа также может быть выражено с помощью утверждения <code>where</code>
непосредственно перед открытием <code>{</code>, а не при первом упоминании типа.
Кроме того, утверждения <code>where</code> могут применять ограничения типажей к 
произвольным типам, а не только к параметрам типа.</p>
<p>В некоторых случаях утверждение <code>where</code> является полезным:</p>
<ul>
<li>При указании обобщённых типов и ограничений типажей отдельно,
код становится более ясным:</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Выражение ограничений типажей через утверждение `where`
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<ul>
<li>Использование утверждения <code>where</code> более выразительно, чем использование
обычного синтаксиса. В этом примере <code>impl</code> не может быть непосредственно
выражен без утверждения <code>where</code>:</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// Потому что в противном случае мы должны были бы выразить это как
// `T: Debug` или использовать другой метод косвенного подхода,
// для этого требуется утверждение `where`:
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // Мы хотим использовать `Option&lt;T&gt;: Debug` как наше ограничение
    // типажа, потому то это то, что будет напечатано. В противном случае
    // использовалось бы неправильное ограничение типажа.
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-38" id="Смотрите-также-38">Смотрите также:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>, <a href="generics/custom_types/structs.html"><code>структуры</code></a>, и <a href="generics/trait.html"><code>типажи</code></a></p>
<h1><a class="header" href="#new-type-idiom" id="new-type-idiom">New Type Idiom</a></h1>
<p>The <code>newtype</code> idiom gives compile time guarantees that the right type of value is supplied
to a program.</p>
<p>For example, an age verification function that checks age in years, <em>must</em> be given
a value of type <code>Years</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    /// truncates partial years
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p>Uncomment the last print statement to observe that the type supplied must be <code>Years</code>.</p>
<h3><a class="header" href="#see-also" id="see-also">See also:</a></h3>
<p><a href="generics/custom_types/structs.html"><code>structs</code></a></p>
<h1><a class="header" href="#associated-items" id="associated-items">Associated items</a></h1>
<p>&quot;Associated Items&quot; refers to a set of rules pertaining to <a href="https://doc.rust-lang.org/reference/items.html"><code>item</code></a>s
of various types. It is an extension to <code>trait</code> generics, and allows 
<code>trait</code>s to internally define new items.</p>
<p>One such item is called an <em>associated type</em>, providing simpler usage 
patterns when the <code>trait</code> is generic over its container type.</p>
<h3><a class="header" href="#see-also-1" id="see-also-1">See also:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<h1><a class="header" href="#the-problem" id="the-problem">The Problem</a></h1>
<p>A <code>trait</code> that is generic over its container type has type specification
requirements - users of the <code>trait</code> <em>must</em> specify all of its generic types.</p>
<p>In the example below, the <code>Contains</code> <code>trait</code> allows the use of the generic 
types <code>A</code> and <code>B</code>. The trait is then implemented for the <code>Container</code> type, 
specifying <code>i32</code> for <code>A</code> and <code>B</code> so that it can be used with <code>fn difference()</code>.</p>
<p>Because <code>Contains</code> is generic, we are forced to explicitly state <em>all</em> of the 
generic types for <code>fn difference()</code>. In practice, we want a way to express that 
<code>A</code> and <code>B</code> are determined by the <em>input</em> <code>C</code>. As you will see in the next 
section, associated types provide exactly that capability.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, &amp;A, &amp;B) -&gt; bool; // Explicitly requires `A` and `B`.
    fn first(&amp;self) -&gt; i32; // Doesn't explicitly require `A` or `B`.
    fn last(&amp;self) -&gt; i32;  // Doesn't explicitly require `A` or `B`.
}

impl Contains&lt;i32, i32&gt; for Container {
    // True if the numbers stored are equal.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `C` contains `A` and `B`. In light of that, having to express `A` and
// `B` again is a nuisance.
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-2" id="see-also-2">See also:</a></h3>
<p><a href="generics/assoc_items/custom_types/structs.html"><code>struct</code>s</a>, and <a href="generics/assoc_items/trait.html"><code>trait</code>s</a></p>
<h1><a class="header" href="#associated-types" id="associated-types">Associated types</a></h1>
<p>The use of &quot;Associated types&quot; improves the overall readability of code 
by moving inner types locally into a trait as <em>output</em> types. Syntax
for the <code>trait</code> definition is as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// `A` and `B` are defined in the trait via the `type` keyword.
// (Note: `type` in this context is different from `type` when used for
// aliases).
trait Contains {
    type A;
    type B;

    // Updated syntax to refer to these new types generically.
    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
}
#}</code></pre></pre>
<p>Note that functions that use the <code>trait</code> <code>Contains</code> are no longer required
to express <code>A</code> or <code>B</code> at all:</p>
<pre><code class="language-rust ignore">// Without using associated types
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// Using associated types
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<p>Let's rewrite the example from the previous section using associated types:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
trait Contains {
    // Define generic types here which methods will be able to utilize.
    type A;
    type B;

    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // Specify what types `A` and `B` are. If the `input` type
    // is `Container(i32, i32)`, the `output` types are determined
    // as `i32` and `i32`.
    type A = i32;
    type B = i32;

    // `&amp;Self::A` and `&amp;Self::B` are also valid here.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h1><a class="header" href="#phantom-type-parameters" id="phantom-type-parameters">Phantom type parameters</a></h1>
<p>A phantom type parameter is one that doesn't show up at runtime,
but is checked statically (and only) at compile time.</p>
<p>Data types can use extra generic type parameters to act as markers
or to perform type checking at compile time. These extra parameters 
hold no storage values, and have no runtime behavior.</p>
<p>In the following example, we combine <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">std::marker::PhantomData</a>
with the phantom type parameter concept to create tuples containing
different data types.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::marker::PhantomData;

// A phantom tuple struct which is generic over `A` with hidden parameter `B`.
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// A phantom type struct which is generic over `A` with hidden parameter `B`.
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// Note: Storage is allocated for generic type `A`, but not for `B`.
//       Therefore, `B` cannot be used in computations.

fn main() {
    // Here, `f32` and `f64` are the hidden parameters.
    // PhantomTuple type specified as `&lt;char, f32&gt;`.
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // PhantomTuple type specified as `&lt;char, f64&gt;`.
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // Type specified as `&lt;char, f32&gt;`.
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // Type specified as `&lt;char, f64&gt;`.
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-3" id="see-also-3">See also:</a></h3>
<p><a href="generics/trait/derive.html">Derive</a>, <a href="generics/custom_types/structs.html">struct</a>, and <a href="generics/custom_types/structs.html">TupleStructs</a></p>
<h1><a class="header" href="#testcase-unit-clarification" id="testcase-unit-clarification">Testcase: unit clarification</a></h1>
<p>A useful method of unit conversions can be examined by implementing <code>Add</code>
with a phantom type parameter. The <code>Add</code> <code>trait</code> is examined below:</p>
<pre><code class="language-rust ignore">// This construction would impose: `Self + RHS = Output`
// where RHS defaults to Self if not specified in the implementation.
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output` must be `T&lt;U&gt;` so that `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`.
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<p>The whole implementation:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::Add;
use std::marker::PhantomData;

/// Create void enumerations to define unit types.
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length` is a type with phantom type parameter `Unit`,
/// and is not generic over the length type (that is `f64`).
///
/// `f64` already implements the `Clone` and `Copy` traits.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// The `Add` trait defines the behavior of the `+` operator.
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() returns a new `Length` struct containing the sum.
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` calls the `Add` implementation for `f64`.
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // Specifies `one_foot` to have phantom type parameter `Inch`.
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter` has phantom type parameter `Mm`.
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+` calls the `add()` method we implemented for `Length&lt;Unit&gt;`.
    //
    // Since `Length` implements `Copy`, `add()` does not consume
    // `one_foot` and `one_meter` but copies them into `self` and `rhs`.
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // Addition works.
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // Nonsensical operations fail as they should:
    // Compile-time Error: type mismatch.
    //let one_feter = one_foot + one_meter;
}
</code></pre></pre>
<h3><a class="header" href="#see-also-4" id="see-also-4">See also:</a></h3>
<p><a href="generics/phantom/scope/borrow.html">Borrowing (<code>&amp;</code>)</a>, <a href="generics/phantom/generics/bounds.html">Bounds (<code>X: Y</code>)</a>, <a href="generics/phantom/custom_types/enum.html">enum</a>, <a href="generics/phantom/fn/methods.html">impl &amp; self</a>,
<a href="generics/phantom/trait/ops.html">Overloading</a>, <a href="generics/phantom/scope/borrow/ref.html">ref</a>, <a href="generics/phantom/trait.html">Traits (<code>X for Y</code>)</a>, and <a href="generics/phantom/custom_types/structs.html">TupleStructs</a>.</p>
<h1><a class="header" href="#Правила-области-видимости" id="Правила-области-видимости">Правила области видимости</a></h1>
<p>Области видимости играют важную роль во владении, заимствовании
и времени жизни. То есть, они указывают компилятору, когда
заимствования действительны, когда ресурсы могут быть освобождены,
и когда переменные создаются или уничтожаются.</p>
<h1><a class="header" href="#raii" id="raii">RAII</a></h1>
<p>Переменные в Rust не только держат данные в стеке, они также могут <em>владеть</em>
ресурсами; к примеру, <code>Box&lt;T&gt;</code> владеет памятью в куче. Поскольку Rust строго
придерживается идиоме <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>, то когда объект выходит за зону видимости, вызывается
его деструктор, а ресурс, которым он <em>владеет</em> освобождается.</p>
<p>Такое поведение защищает от багов, связанных с <em>утечкой ресурсов.</em>
Вам больше никогда не потребуется вручную освобождать память или же беспокоиться
об её утечках! Небольшой пример:</p>
<pre><pre class="playpen"><code class="language-rust editable">// raii.rs
fn create_box() {
    // Выделить память для целого число в куче
    let _box1 = Box::new(3i32);

    // `_box1` здесь уничтожается, а память освобождается
}

fn main() {
    // Выделить память для целого числа в куче
    let _box2 = Box::new(5i32);

    // Вложенная область видимости:
    {
        // Выделить память для ещё одного целого числа в куче
        let _box3 = Box::new(4i32);

        // `_box3` здесь уничтожается, а память освобождается
    }

    // Создаём большое количество упаковок. Просто потому что можем.
    // Здесь нет необходимости освобождать память вручную!
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` здесь уничтожается, а память освобождается
}
</code></pre></pre>
<p>Конечно, мы можем убедиться, что в нашей программе нет ошибок с памятью,
используя <a href="http://valgrind.org/info/"><code>valgrind</code></a>:</p>
<pre><code class="language-bash">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>Утечки отсутствуют!</p>
<h2><a class="header" href="#Деструктор" id="Деструктор">Деструктор</a></h2>
<p>Понятие деструктора в Rust обеспечивается через типаж <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>.
Деструктор вызывается, когда ресурс выходит за пределы области видимости.
Этот типаж не требуется реализовать для каждого типа.
Реализовать его для вашего типа вам потребуется, только если
требуется своя логика при удалении экземпляра типа.</p>
<p>Выполните пример ниже, чтобы увидеть, как работает типаж [<code>Drop']. Когда переменная в функции </code>main` выходит за пределы области действия,
будет вызван пользовательский деструктор.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-39" id="Смотрите-также-39">Смотрите также:</a></h3>
<p><a href="scope/std/box.html">Упаковка</a></p>
<h1><a class="header" href="#Владение-и-перемещение" id="Владение-и-перемещение">Владение и перемещение</a></h1>
<p>Поскольку переменные ответственны за освобождение своих ресурсов,
<strong>ресурсы могут иметь лишь одного владельца</strong>.  Это ограничение предотвращает
возможность высвобождения ресурсов более одно раза. Обратите внимание,
что не все переменные владеют своим ресурсом (например, <a href="scope/flow_control/match/destructuring/destructure_pointers.html">ссылки</a>).</p>
<p>При присваивании (<code>let x = y</code>) или при передаче функции аргумента по значению (<code>foo(x)</code>),
<em>владение</em> ресурсами передаётся. В языке Rust это называется <em>перемещением.</em></p>
<p>После перемещения ресурсов, переменная, владевшая ресурсами ранее, не может быть
использована. Это предотвращает создание висячих указателей.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Эта функция берёт во владение память, выделенную в куче
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Уничтожаем упаковку, в которой хранится {}&quot;, c);

    // `c` уничтожится, а память будет освобождена
}

fn main() {
    // Целое число выделенное в стеке
    let x = 5u32;

    // *Копируем* `x` в `y`. В данном случае нет ресурсов для перемещения
    let y = x;

    // Оба значения можно использовать независимо
    println!(&quot;x равен {}, а y равен {}&quot;, x, y);

    // `a` - указатель на целое число, выделенное в куче
    let a = Box::new(5i32);

    println!(&quot;a содержит: {}&quot;, a);

    // *Перемещаем* `a` в `b`
    let b = a;
    // Адрес указателя `a` копируется (но не данные) в `b`.
    // Оба указателя указывают на одни и те же данные в куче, но
    // `b` теперь владеет ими.

    // Ошибка! `a` больше не может получить доступ к данным, потому что
    // больше не владеет данными в куче.
    //println!(&quot;a содержит: {}&quot;, a);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Эта функция берет во владение память, выделенную в куче, которой ранее владела `b`
    destroy_box(b);

    // Поскольку в данный момент память в куче уже освобождена, это действие
    // приведёт к разыменованию освобождённой памяти, но это запрещено компилятором
    // Ошибка! Причина та же, что и в прошлый раз
    //println!(&quot;b содержит: {}&quot;, b);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку
}
</code></pre></pre>
<h1><a class="header" href="#Изменяемость-1" id="Изменяемость-1">Изменяемость</a></h1>
<p>Изменяемость данных может быть изменена при передаче владения.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box содержит в себе {}&quot;, immutable_box);

    // Ошибка изменяемости
    //*immutable_box = 4;

    // *Переместить* упаковку, изменив её владение (и изменяемость)
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box содержит в себе {}&quot;, mutable_box);

    // Изменяем данные внутри упаковки
    *mutable_box = 4;

    println!(&quot;mutable_box now содержит в себе {}&quot;, mutable_box);
}
</code></pre></pre>
<h1><a class="header" href="#Заимствование" id="Заимствование">Заимствование</a></h1>
<p>Большую часть времени мы хотим обращаться к данным без получения владения над
ними. Для этого Rust предоставляет механизм <em>заимствования</em> Вместо передачи
объектов по значению (<code>T</code>), объекты могут быть переданы по ссылке (<code>&amp;T</code>).</p>
<p>Компилятор статически гарантирует, что ссылки <em>всегда</em> указывают на допустимые
объекты посредством проверки заимствований. К примеру, исходный объект не может
быть уничтожен, пока существуют ссылки на него.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Эта функция берёт во владение упаковку и уничтожает её
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Уничтожаем упаковку в которой хранится {}&quot;, boxed_i32);
}

// Эта функция заимствует i32
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;Это число равно: {}&quot;, borrowed_i32);
}

fn main() {
    // Создаём упакованное i32, и i32 на стеке
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Заимствуем содержимое упаковки. При этом мы не владеем ресурсом.
    // Содержимое может быть заимствовано снова.
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // Получаем ссылку на данные, которые хранятся внутри упаковки
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // Ошибка!
        // Нельзя уничтожать упаковку `boxed_i32` пока данные внутри заимствованы.
        eat_box_i32(boxed_i32);
        // ИСПРАВЬТЕ ^ Закомментируйте эту строку

        // `_ref_to_i32` покидает область видимости и больше не является заимствованным ресурсом.
    }

    // `boxed_i32` теперь может получить владение над `eat_box` и быть уничтожено
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<h1><a class="header" href="#mutability" id="mutability">Mutability</a></h1>
<p>Mutable data can be mutably borrowed using <code>&amp;mut T</code>. This is called 
a <em>mutable reference</em> and gives read/write access to the borrower.
In contrast, <code>&amp;T</code> borrows the data via an immutable reference, and 
the borrower can read the data but not modify it:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` is a reference to a string allocated in read only memory
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// This function takes a reference to a book
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// This function takes a reference to a mutable book and changes `year` to 2014
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // Create an immutable Book named `immutabook`
    let immutabook = Book {
        // string literals have type `&amp;'static str`
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // Create a mutable copy of `immutabook` and call it `mutabook`
    let mut mutabook = immutabook;
    
    // Immutably borrow an immutable object
    borrow_book(&amp;immutabook);

    // Immutably borrow a mutable object
    borrow_book(&amp;mutabook);
    
    // Borrow a mutable object as mutable
    new_edition(&amp;mut mutabook);
    
    // Error! Cannot borrow an immutable object as mutable
    new_edition(&amp;mut immutabook);
    // FIXME ^ Comment out this line
}
</code></pre></pre>
<h3><a class="header" href="#see-also-5" id="see-also-5">See also:</a></h3>
<p><a href="scope/borrow/scope/lifetime/static_lifetime.html"><code>static</code></a></p>
<h1><a class="header" href="#Замораживание" id="Замораживание">Замораживание</a></h1>
<p>Когда данные заимствуются, они заодно и <em>замораживаются</em>. <em>Замороженные</em> данные
не могут быть изменены до тех пор, пока все ссылки не выйдут за область видимости:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // Заимствовать `_mutable_integer`
        let _large_integer = &amp;_mutable_integer;

        // Ошибка! `_mutable_integer` заморожен в этой области видимости
        _mutable_integer = 50;
        // ИСПРАВЬТЕ ^ Закомментируйте эту строку

        // `_large_integer` покидает область видимости
    }

    // Ок! `_mutable_integer` не заморожен в этой области видимости
    _mutable_integer = 3;
}
</code></pre></pre>
<h1><a class="header" href="#aliasing" id="aliasing">Aliasing</a></h1>
<p>Data can be immutably borrowed any number of times, but while immutably
borrowed, the original data can't be mutably borrowed. On the other hand,
only <em>one</em> mutable borrow is allowed at a time. The original data can be
borrowed again only <em>after</em> the mutable reference goes out of scope.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    {
        let borrowed_point = &amp;point;
        let another_borrow = &amp;point;

        // Data can be accessed via the references and the original owner
        println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                 borrowed_point.x, another_borrow.y, point.z);

        // Error! Can't borrow point as mutable because it's currently
        // borrowed as immutable.
        //let mutable_borrow = &amp;mut point;
        // TODO ^ Try uncommenting this line

        // Immutable references go out of scope
    }

    {
        let mutable_borrow = &amp;mut point;

        // Change data via mutable reference
        mutable_borrow.x = 5;
        mutable_borrow.y = 2;
        mutable_borrow.z = 1;

        // Error! Can't borrow `point` as immutable because it's currently
        // borrowed as mutable.
        //let y = &amp;point.y;
        // TODO ^ Try uncommenting this line

        // Error! Can't print because `println!` takes an immutable reference.
        //println!(&quot;Point Z coordinate is {}&quot;, point.z);
        // TODO ^ Try uncommenting this line

        // Ok! Mutable references can be passed as immutable to `println!`
        println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                 mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

        // Mutable reference goes out of scope
    }

    // Immutable references to point are allowed again
    let borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             borrowed_point.x, borrowed_point.y, borrowed_point.z);
}
</code></pre></pre>
<h1><a class="header" href="#the-ref-pattern" id="the-ref-pattern">The ref pattern</a></h1>
<p>When doing pattern matching or destructuring via the <code>let</code> binding, the <code>ref</code>
keyword can be used to take references to the fields of a struct/tuple. The 
example below shows a few instances where this can be useful:</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // A `ref` borrow on the left side of an assignment is equivalent to
    // an `&amp;` borrow on the right side.
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` is also valid when destructuring a struct.
    let _copy_of_x = {
        // `ref_to_x` is a reference to the `x` field of `point`.
        let Point { x: ref ref_to_x, y: _ } = point;

        // Return a copy of the `x` field of `point`.
        *ref_to_x
    };

    // A mutable copy of `point`
    let mut mutable_point = point;

    {
        // `ref` can be paired with `mut` to take mutable references.
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // Mutate the `y` field of `mutable_point` via a mutable reference.
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // A mutable tuple that includes a pointer
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // Destructure `mutable_tuple` to change the value of `last`.
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<h1><a class="header" href="#Времена-жизни" id="Времена-жизни">Времена жизни</a></h1>
<p><em>Время жизни</em> - это конструкция, которую компилятор (или более конкретно,
его анализатор заимствований) использует, чтобы убедиться, что все
заимствования действительны. В частности время жизни переменной
начинается с момента её создания и заканчивается когда она уничтожается.
Времена жизни и области видимости упоминаются часто вместе, но
они не совпадают.</p>
<p>Возьмём, например, случай когда мы заимствуем переменную через <code>&amp;</code>.
Срок действия заимствования определяется местом его объявления.
В результате, заимствование действительно до тех пор,
пока оно не закончится или пока кредитор не будет уничтожен. Однако,
область заимствования определяется местом использования ссылки.</p>
<p>В следующем примере и в остальной части этого раздела мы увидим, как
времена жизни связаны с областями видимости, а также как они различаются.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Времена жизни аннотированы линиями, обозначающими
// создание и уничтожение каждой переменной.
// `i` имеет самое длинное время жизни, так как его область охватывает
// полностью оба заимствования `borrow1` и `borrow2`.
// Продолжительность заимствования `borrow1` по сравнению с
// заимствованием `borrow2` не имеет значения, так как они не пересекаются.
fn main() {
    let i = 3; // Lifetime for `i` starts. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1 ends. ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` ends. ─────────────────────────────────┘│
    //                                                     │
}   // Lifetime ends. ─────────────────────────────────────┘
</code></pre></pre>
<p>Обратите внимание, что для меток времени жизни не назначаются имена или типы.
Это ограничивает то, как время жизни будет использоваться, как мы увидим далее.</p>
<h1><a class="header" href="#explicit-annotation" id="explicit-annotation">Explicit annotation</a></h1>
<p>The borrow checker uses explicit lifetime annotations to determine
how long references should be valid. In cases where lifetimes are not
elided<sup class="footnote-reference"><a href="#1">1</a></sup>, Rust requires explicit annotations to determine what the 
lifetime of a reference should be. The syntax for explicitly annotating 
a lifetime uses an apostrophe character as follows: </p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo` has a lifetime parameter `'a`
</code></pre>
<p>Similar to <a href="scope/lifetime/fn/closures/anonymity.html">closures</a>, using lifetimes requires generics. 
Additionally, this lifetime syntax indicates that the lifetime of <code>foo</code> 
may not exceed that of <code>'a</code>. Explicit annotation of a type has the form 
<code>&amp;'a T</code> where <code>'a</code> has already been introduced.</p>
<p>In cases with multiple lifetimes, the syntax is similar:</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo` has lifetime parameters `'a` and `'b`
</code></pre>
<p>In this case, the lifetime of <code>foo</code> cannot exceed that of either <code>'a</code> <em>or</em> <code>'b</code>.</p>
<p>See the following example for explicit lifetime annotation in use:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// `print_refs` takes two references to `i32` which have different
// lifetimes `'a` and `'b`. These two lifetimes must both be at
// least as long as the function `print_refs`.
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// A function which takes no arguments, but has a lifetime parameter `'a`.
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR: `_x` does not live long enough
    //let y: &amp;'a i32 = &amp;_x;
    // Attempting to use the lifetime `'a` as an explicit type annotation 
    // inside the function will fail because the lifetime of `&amp;_x` is shorter
    // than that of `y`. A short lifetime cannot be coerced into a longer one.
}

fn main() {
    // Create variables to be borrowed below.
    let (four, nine) = (4, 9);
    
    // Borrows (`&amp;`) of both variables are passed into the function.
    print_refs(&amp;four, &amp;nine);
    // Any input which is borrowed must outlive the borrower. 
    // In other words, the lifetime of `four` and `nine` must 
    // be longer than that of `print_refs`.
    
    failed_borrow();
    // `failed_borrow` contains no references to force `'a` to be 
    // longer than the lifetime of the function, but `'a` is longer.
    // Because the lifetime is never constrained, it defaults to `'static`.
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="scope/lifetime/scope/lifetime/elision.html">elision</a> implicitly annotates lifetimes and so is different.</p>
</div>
<h3><a class="header" href="#see-also-6" id="see-also-6">See also:</a></h3>
<p><a href="scope/lifetime/generics.html">generics</a> and <a href="scope/lifetime/fn/closures.html">closures</a></p>
<h1><a class="header" href="#Функции-2" id="Функции-2">Функции</a></h1>
<p>Сигнатуры функции с указанием времени жизни имеют некоторые ограничения:</p>
<ul>
<li>любая ссылка <em>должна</em> иметь аннотированное время жизни</li>
<li>любая возвращаемая ссылка <em>должна</em> иметь то же время жизни, что входящая ссылкаили <code>static</code>.</li>
</ul>
<p>Кроме того, обратите внимание, что возврат ссылок из функции, которая не имеет ссылок во входных аргументах, запрещен, если он
приведет к возвращению ссылок на недопустимые данные. В следующем примере показаны
некоторые действительные формы функции со временем жизни:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Одна входная ссылка со временем жизни `'a`, которая
// будет жить как минимум до конца функции.
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// Использование времени жизни также возможно с изменяемыми ссылками.
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// Несколько элементов с различными временами жизни. В этом случае
// было бы хорошо, чтобы у обоих ссылок было одно время жизни `'a`,
// в более сложных случаях может потребоваться различное время жизни.
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// Возврат переданных на вход ссылок допустим.
// Однако должен быть указано правильное время жизни.
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }
// Код написанный выше является недопустимым: время жизни `'a`
// должно жить после выхода из функции.
// Здесь, `&amp;String::from(&quot;foo&quot;)` создает ссылку на `String`
// Данные будут удалены после выхода из области видимости, и
// будет возвращена ссылка на недопустимые данные.

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-40" id="Смотрите-также-40">Смотрите также:</a></h3>
<p><a href="scope/lifetime/fn.html">функции</a></p>
<h1><a class="header" href="#Методы" id="Методы">Методы</a></h1>
<p>Методы аннотируются аналогично функциям:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Owner(i32);

impl Owner {
    // Время жизни аннотируется как в отдельной функции.
    fn add_one&lt;'a&gt;(&amp;'a mut self) {
        self.0 += 1;
    }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-41" id="Смотрите-также-41">Смотрите также:</a></h3>
<p><a href="scope/lifetime/fn/methods.html"><code>Методы</code></a></p>
<h1><a class="header" href="#Структуры-2" id="Структуры-2">Структуры</a></h1>
<p>Аннотирование времени жизни в структурах аналогично функциям:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Тип `Borrowed`, в котором находится ссылка на `i32`.
// Ссылка на `i32` должна пережить `Borrowed`.
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// Аналогично, обе ссылки расположенные здесь, должны пережить эту структуру.
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// Перечисление, которое указывает на `i32` или на ссылку.
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number = Either::Num(y);

    println!(&quot;x заимствован в {:?}&quot;, single);
    println!(&quot;x и y заимствованы в {:?}&quot;, double);
    println!(&quot;x заимствован в {:?}&quot;, reference);
    println!(&quot;y *не* заимствован в {:?}&quot;, number);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-42" id="Смотрите-также-42">Смотрите также:</a></h3>
<p><a href="scope/lifetime/custom_types/structs.html"><code>Структуры</code></a></p>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<p>Annotation of lifetimes in trait methods basically are similar to functions.
Note that <code>impl</code> may have annotation of lifetimes too.</p>
<pre><pre class="playpen"><code class="language-rust editable">// A struct with annotation of lifetimes.
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// Annotate lifetimes to impl.
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b is {:?}&quot;, b);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-7" id="see-also-7">See also:</a></h3>
<p><a href="scope/lifetime/../../trait.html"><code>trait</code>s</a></p>
<h1><a class="header" href="#Ограничения-1" id="Ограничения-1">Ограничения</a></h1>
<p>Так же как и обобщённые типы, время жизни (обобщённое само по себе) могут быть ограничены.
Знак <code>:</code> имеет немного другое значение,
но  знак <code>+</code> такое же. Прочитайте следующую заметку:</p>
<ol>
<li><code>T: 'a</code>: <em>Все</em> ссылки в <code>T</code> должны пережить время жизни <code>'a</code>.</li>
<li><code>T: Trait + 'a</code>: Тип <code>T</code> должен реализовать типаж <code>Trait</code> и <em>все</em> ссылки
в <code>T</code> должны пережить <code>'a</code>.</li>
</ol>
<p>Пример ниже демонстрирует синтаксис в действии:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug; // Типаж с ограничениями.

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` содержит ссылки на обобщённый тип `T` который имеет
// неизвестное время жизни `'a`. `T` ограничен так, что любые
// *ссылки* в `T` должны пережить `'a`.
// Кроме того, время жизни `Ref` не может превышать `'a`.

// Обобщённая функция, которая показывает использование типажа `Debug`.
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t это {:?}&quot;, t);
}

// Здесь приводится ссылка на `T`, где `T` реализует
// `Debug` и все *ссылки* в `T` переживут `'a`.
// К тому же, `'a` должен пережить функцию.
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t это {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-43" id="Смотрите-также-43">Смотрите также:</a></h3>
<p><a href="scope/lifetime/generics.html">generics</a>, <a href="scope/lifetime/generics/bounds.html">bounds in generics</a>, and 
<a href="scope/lifetime/generics/multi_bounds.html">multiple bounds in generics</a></p>
<h1><a class="header" href="#coercion" id="coercion">Coercion</a></h1>
<p>A longer lifetime can be coerced into a shorter one 
so that it works inside a scope it normally wouldn't work in.
This comes in the form of inferred coercion by the Rust compiler,
and also in the form of declaring a lifetime difference:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Here, Rust infers a lifetime that is as short as possible.
// The two references are then coerced to that lifetime.
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` reads as lifetime `'a` is at least as long as `'b`.
// Here, we take in an `&amp;'a i32` and return a `&amp;'b i32` as a result of coercion.
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // Longer lifetime
    
    {
        let second = 3; // Shorter lifetime
        
        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<h1><a class="header" href="#static" id="static">Static</a></h1>
<p>A <code>'static</code> lifetime is the longest possible lifetime, and lasts for 
the lifetime of the running program. A <code>'static</code> lifetime may also be 
coerced to a shorter lifetime. There are two ways to make a variable 
with <code>'static</code> lifetime, and both are stored in the read-only memory
of the binary:</p>
<ul>
<li>Make a constant with the <code>static</code> declaration.</li>
<li>Make a <code>string</code> literal which has type: <code>&amp;'static str</code>.</li>
</ul>
<p>See the following example for a display of each method:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Make a constant with `'static` lifetime.
static NUM: i32 = 18;

// Returns a reference to `NUM` where its `'static` 
// lifetime is coerced to that of the input argument.
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // Make a `string` literal and print it:
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // When `static_string` goes out of scope, the reference
        // can no longer be used, but the data remains in the binary.
    }
    
    {
        // Make an integer to use for `coerce_static`:
        let lifetime_num = 9;

        // Coerce `NUM` to lifetime of `lifetime_num`:
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }
    
    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-8" id="see-also-8">See also:</a></h3>
<p><a href="scope/lifetime/custom_types/constants.html"><code>'static</code> constants</a></p>
<h1><a class="header" href="#elision" id="elision">Elision</a></h1>
<p>Some lifetime patterns are overwelmingly common and so the borrow checker
will implicitly add them to save typing and to improve readability.
This process of implicit addition is called elision. Elision exists in Rust
solely because these patterns are common.</p>
<p>The following code shows a few examples of elision. For a more comprehensive
description of elision, see <a href="https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision">lifetime elision</a> in the book.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `elided_input` and `annotated_input` essentially have identical signatures
// because the lifetime of `elided_input` is elided by the compiler:
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x);
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x);
}

// Similarly, `elided_pass` and `annotated_pass` have identical signatures
// because the lifetime is added implicitly to `elided_pass`:
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-9" id="see-also-9">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision">elision</a></p>
<h1><a class="header" href="#Типажи-1" id="Типажи-1">Типажи</a></h1>
<p><code>Типаж (trait)</code> - это набор методов, определённых для неизвестного типа:
<code>Self</code>. Они могут получать доступ к другим методам,
которые были объявлены в том же типаже.</p>
<p>Типажи могут быть реализованы для любых типов данных. В примере ниже,
мы определили группу методов <code>Animal</code>. Типаж <code>Animal</code> реализован для типа данных
<code>Sheep</code>, что позволяет использовать методы из <code>Animal</code> внутри <code>Sheep</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // Сигнатура статического метода, `Self` ссылается на реализующий тип.
    fn new(name: &amp;'static str) -&gt; Self;

    // Сигнатура метода экземпляра; они возвращают строки.
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // Типаж может содержать определение метода по умолчанию
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // Методы типа могут использовать методы типажа, реализованного для этого типа.
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// Реализуем типаж `Animal` для `Sheep`.
impl Animal for Sheep {
    // `Self` реализующий тип: `Sheep`.
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }

    // Методы по умолчанию могут быть переопределены.
    fn talk(&amp;self) {
        // Например, мы добавили немного спокойного миросозерцания...
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // Аннотация типа в данном случае необходима.
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // ЗАДАНИЕ ^ Попробуйте убрать аннотацию типа

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<h1><a class="header" href="#Атрибут-derive" id="Атрибут-derive">Атрибут <code>Derive</code></a></h1>
<p>Компилятор способен предоставить основные реализации для некоторых типажей
с помощью <a href="trait/../attribute.html">атрибута</a> <code>#[derive]</code>. Эти типажи могут быть
реализованы вручную, если необходимо более сложное поведение.</p>
<p>Ниже приводится список выводимых типажей:</p>
<ul>
<li>Типажи сравнения:<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, для создания <code>T</code> из <code>&amp;T</code> с помощью копии.</li>
<li><a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a>, чтобы создать тип семантикой копирования, вместо семантики перемещения.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>, чтобы вычислить хеш из <code>&amp;T</code>.</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>, чтобы создать пустой экземпляр типа данных.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>, чтобы отформатировать значение с помощью <code>{:?}</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">// `Centimeters`, кортежная структура, которую можно сравнить
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, кортежная структура, которую можно напечатать
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`, кортежная структура без дополнительных атрибутов
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // Ошибка: `Seconds` не может быть напечатана; не реализован типаж `Debug`
    //println!(&quot;Одна секунда выглядит как: {:?}&quot;, _one_second);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Ошибка: `Seconds` нельзя сравнить; не реализован типаж `PartialEq`
    //let _this_is_true = (_one_second == _one_second);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    let foot = Inches(12);

    println!(&quot;Один фут равен {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;меньше&quot;
        } else {
            &quot;больше&quot;
        };

    println!(&quot;Один фут {} одного метра.&quot;, cmp);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-44" id="Смотрите-также-44">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#derive"><code>derive</code></a></p>
<h1><a class="header" href="#Перегрузка-операторов" id="Перегрузка-операторов">Перегрузка операторов</a></h1>
<p>В Rust, множество операторов могут быть перегружены с помощью типажей. То есть, некоторые
операторы могут использоваться для выполнения различных задач на основе вводимых аргументов.
Это возможно, потому что операторы являются синтаксическим сахаром для вызова методов. Например,
оператор <code>+</code> в <code>a + b</code> вызывает метод <code>add</code> (как в <code>a.add(b)</code>).
Метод <code>add</code> является частью типажа <code>Add</code>.
Следовательно, оператор <code>+</code> могут использовать все, кто реализуют типаж <code>Add</code>.</p>
<p>Список типажей, таких как <code>Add</code>, которые перегружают операторы, доступен <a href="https://doc.rust-lang.org/core/ops/">здесь</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// Типаж `std::ops::Add` используется для указания функциональности `+`.
// Здесь мы объявим `Add&lt;Bar&gt;` - типаж сложения, со вторым
// операндом типа `Bar`.
// Следующий блок реализует операцию: Foo + Bar = FooBar
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Вызвали Foo.add(Bar)&quot;);

        FooBar
    }
}

// Если мы поменяем местами типы, то получим реализацию некоммутативного сложения.
// Здесь мы объявим `Add&lt;Foo&gt;` - типаж сложения, со вторым
// операндом типа `Foo`.
// Этот блок реализует операцию: Bar + Foo = BarFoo
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Вызвали Bar.add(Foo)&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-45" id="Смотрите-также-45">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/core/ops/trait.Add.html">Add</a>, <a href="https://doc.rust-lang.org/book/second-edition/appendix-02-operators.html">Syntax Index</a></p>
<h1><a class="header" href="#Типаж-drop" id="Типаж-drop">Типаж Drop</a></h1>
<p>Типаж <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> имеет только один метод: <code>drop</code>, который вызывается автоматически,
когда объект выходит из области видимости. Основное применение типажа <code>Drop</code>
заключается в том, чтобы освободить ресурсы, которыми владеет экземпляр реализации.</p>
<p><code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, и <code>Process</code> - это некоторые примеры типов, которые
реализуют типаж <code>Drop</code> для освобождения ресурсов. Типаж <code>Drop</code> также может быть
реализован вручную для любых индивидуальных типов данных.</p>
<p>В следующем примере мы добавим вывод в консоль к функции <code>drop</code>, чтобы было видно,
когда она вызывается.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

// Это простая реализация `drop`, которая добавляет вывод в консоль.
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Сбросили {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // блок А
    {
        let _b = Droppable { name: &quot;b&quot; };

        // блок Б
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Выходим из блока Б&quot;);
        }
        println!(&quot;Вышли из блока Б&quot;);

        println!(&quot;Выходим из блока А&quot;);
    }
    println!(&quot;Вышли из блока А&quot;);

    // Переменную можно сбросить вручную с помощью функции `drop`.
    drop(_a);
    // ЗАДАНИЕ ^ Попробуйте закомментировать эту строку

    println!(&quot;Конец главной функции.&quot;);

    // *Нельзя* сбросить `_a` снова, потому что переменная уже
    // (вручную) сброшена.
}
</code></pre></pre>
<h1><a class="header" href="#Итераторы" id="Итераторы">Итераторы</a></h1>
<p>Типаж <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> используется для итерирования
по коллекциям, таким как массивы.</p>
<p>Типаж требует определить метод <code>next</code>, для получения следующего элемента.
Данный метод в блоке <code>impl</code> может быть определён
вручную или автоматически (как в массивах и диапазонах).</p>
<p>Для удобства использования, например в цикле <code>for</code>, некоторые коллекции
превращаются в итераторы с помощью метода <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>.into_iterator()</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

// Реализация `Iterator` для `Fibonacci`.
// Для реализации типажа `Iterator` требуется реализовать метод `next`.
impl Iterator for Fibonacci {
    type Item = u32;
    
    // Здесь мы определяем последовательность, используя `.curr` и `.next`.
    // Возвращаем тип `Option&lt;T&gt;`:
    //     * Когда в `Iterator` больше нет значений, будет возвращено `None`.
    //     * В противном случае следующее значение оборачивается в `Some` и возвращается.
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // Поскольку последовательность Фибоначчи бесконечна,
        // то `Iterator` никогда не вернет `None`, и всегда будет
        // возвращаться `Some`.
        Some(self.curr)
    }
}

// Возвращается генератор последовательности Фибоначчи.
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 1, next: 1 }
}

fn main() {
    // `0..3` это `Iterator`, который генерирует : 0, 1, и 2.
    let mut sequence = 0..3;

    println!(&quot;Четыре подряд вызова `next`на 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for` работает через `Iterator` пока тот не вернет `None`.
    // каждое значение `Some` распаковывается  и привязывается к переменной (здесь это `i`).
    println!(&quot;Итерирование по 0..3 используя `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // Метод `take(n)` уменьшает `Iterator` до его первых `n` членов.
    println!(&quot;Первые четыре члена последовательности Фибоначчи: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // Метод `skip(n)` сокращает `Iterator`, отбрасывая его первые `n` членов.
    println!(&quot;Следующие четыре члена последовательности Фибоначчи: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // Метод `iter` превращает `Iterator` в массив/срез.
    println!(&quot;Итерирование по массиву {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<h1><a class="header" href="#Типаж-clone" id="Типаж-clone">Типаж Clone</a></h1>
<p>При работе с ресурсами, стандартным поведением является передача их (ресурсов)
в ходе выполнения или вызов функции. Однако, иногда нам нужно
также объявить копию ресурса.</p>
<p>Типаж <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> помогает нам сделать именно это. Чаще всего, мы можем
использовать метод <code>.clone()</code> объявленный типажом <code>Clone</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Единичная структура без ресурсов
#[derive(Debug, Clone, Copy)]
struct Nil;

// Кортежная структура с ресурсами, которая реализует типаж `Clone`
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // Объявим экземпляр `Nil`
    let nil = Nil;
    // Скопируем `Nil`, который не имеет ресурсов для перемещения
    let copied_nil = nil;

    // Оба `Nil`s могут быть использованы независимо
    println!(&quot;оригинал: {:?}&quot;, nil);
    println!(&quot;копия: {:?}&quot;, copied_nil);

    // Объявим экземпляр `Pair`
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;оригинал: {:?}&quot;, pair);

    // Скопируем `pair` в `moved_pair`, перенаправляя ресурсы
    let moved_pair = pair;
    println!(&quot;копия: {:?}&quot;, moved_pair);

    // Ошибка! `pair` потеряла свои ресурсы
    //println!(&quot;оригинал: {:?}&quot;, pair);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Скопируем `moved_pair` в `cloned_pair` (включая ресурсы)
    let cloned_pair = moved_pair.clone();
    // Сбросим оригинальную пару используя std::mem::drop
    drop(moved_pair);

    // Ошибка! `moved_pair` была сброшена
    //println!(&quot;копия: {:?}&quot;, moved_pair);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Полученный результат из .clone() все ещё можно использовать!
    println!(&quot;клон: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<h1><a class="header" href="#macro_rules" id="macro_rules">macro_rules!</a></h1>
<p>Rust предоставляет мощную систему макросов, которая позволяет
использовать метапрограммирование. Как вы могли видеть в предыдущих главах,
макросы выглядят как функции, но их имя заканчивается восклицательным знаком (<code>!</code>).
Вместо вызова функции, макросы расширяются в исходный код, который впоследствии
компилируется с остальной частью программы.
Однако, в отличие от макросов на C и других языках, макросы Rust расширяются
в абстрактные синтаксические деревья, а не в подстановку строк,
поэтому Вы не получаете неожиданных ошибок приоритета операций.</p>
<p>Макросы создаются с помощью макроса <code>macro_rules!</code></p>
<pre><pre class="playpen"><code class="language-rust editable">// Этот простой макрос называется `say_hello`.
macro_rules! say_hello {
    // `()` указывает, что макрос не принимает аргументов.
    () =&gt; (
        // Макрос будет раскрываться с содержимым этого блока.
        println!(&quot;Hello!&quot;);
    )
}

fn main() {
    // Этот вызов будет раскрыт в код `println!(&quot;Hello&quot;);`
    say_hello!()
}
</code></pre></pre>
<p>Так почему же макросы полезны?</p>
<ol>
<li>
<p>Не повторяйтесь. Есть много случаев, когда вам может понадобиться подобная
функциональность в нескольких местах, но с различными типами. Часто пишут
макрос - это полезный способ избежать повторения кода. (Подробнее об этом позже)</p>
</li>
<li>
<p>Предметно ориентированные языки. Макросы позволяют определить специальный синтаксис для
конкретной цели. (Подробнее об этом позже)</p>
</li>
<li>
<p>Вариативные интерфейсы. Иногда требуется определить интерфейс, который
имеет переменное количество аргументов. Пример: <code>println!</code>, который может принять любое
количество аргументов в зависимости от строки формата. (Подробнее об этом позже)</p>
</li>
</ol>
<h1><a class="header" href="#syntax" id="syntax">Syntax</a></h1>
<p>In following subsections, we will show how to define macros in Rust.
There are three basic ideas:</p>
<ul>
<li><a href="macros/macros/designators.html">Patterns and Designators</a></li>
<li><a href="macros/macros/overload.html">Overloading</a></li>
<li><a href="macros/macros/repeat.html">Repetition</a></li>
</ul>
<h1><a class="header" href="#Указатели" id="Указатели">Указатели</a></h1>
<p>Аргументы макроса имеют префикс знака доллара <code>$</code> и тип аннотируется
с помощью <em>указателей фрагмента</em>:</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! create_function {
    // Этот макрос принимает аргумент идентификатора `ident` и
    // создаёт функцию с именем `$func_name`.
    // Идентификатор `ident` используют для обозначения имени переменной/функции.
    ($func_name:ident) =&gt; (
        fn $func_name() {
            // Макрос `stringify!` преобразует `ident` в строку.
            println!(&quot;Вызвана функция {:?}()&quot;,
                     stringify!($func_name))
        }
    )
}

// Создадим функции с именами `foo` и `bar` используя макрос, указанный выше.
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // Этот макрос принимает выражение типа `expr` и напечатает
    // его как строку вместе с результатом.
    // Указатель `expr` используют для обозначения выражений.
    ($expression:expr) =&gt; (
        // `stringify!` преобразует выражение в строку *без изменений*.
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression);
    )
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // Напомним, что блоки тоже являются выражениями!
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>Это список всех указателей:</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code> используют для обозначения выражений</li>
<li><code>ident</code> используют для обозначения имени переменной/функции</li>
<li><code>item</code></li>
<li><code>literal</code> используется для литеральных констант</li>
<li><code>pat</code> (<em>образец</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<em>единственный оператор</em>)</li>
<li><code>tt</code> (<em>единственное дерево лексем</em>)</li>
<li><code>ty</code> (<em>тип</em>)</li>
<li><code>vis</code> (<em>спецификатор видимости</em>)</li>
</ul>
<p>Полный список указателей, вы можете увидеть в <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust Reference</a>.</p>
<h1><a class="header" href="#Перегрузка" id="Перегрузка">Перегрузка</a></h1>
<p>Макросы могут быть перегружены, принимая различные комбинации аргументов.
В этом плане, <code>macro_rules!</code> может работать аналогично блоку сопоставления (match):</p>
<pre><pre class="playpen"><code class="language-rust editable">// `test!` будет сравнивать `$left` и `$right`
// по разному, в зависимости от того, как вы объявите их:
macro_rules! test {
    // Не нужно разделять аргументы запятой.
    // Можно использовать любой шаблон!
    ($left:expr; and $right:expr) =&gt; (
        println!(&quot;{:?} и {:?} это {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    );
    // ^ каждый блок должен заканчиваться точкой с запятой.
    ($left:expr; or $right:expr) =&gt; (
        println!(&quot;{:?} или {:?} это {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    );
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<h1><a class="header" href="#Повторение" id="Повторение">Повторение</a></h1>
<p>Макросы могут использовать знак <code>+</code> в списке аргументов, чтобы указать, какие аргументы
могут повторяться хоть один раз, или знак <code>*</code>, чтобы указать, какие аргументы могут
повторяться ноль или несколько раз.</p>
<p>В следующем примере, шаблон, окружённый <code>$(...),+</code> будет
сопоставлять одно или несколько выражений, разделённых запятыми.
Также обратите внимание, что точка с запятой является
необязательной в последнем случае.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `min!` посчитает минимальное число аргументов.
macro_rules! find_min {
    // Простой вариант:
    ($x:expr) =&gt; ($x);
    // `$x` следует хотя бы одному `$y,`
    ($x:expr, $($y:expr),+) =&gt; (
        // Вызовем `find_min!` на конце `$y`
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2 , 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<h1><a class="header" href="#dry-Не-повторяйся" id="dry-Не-повторяйся">DRY (Не повторяйся)</a></h1>
<p>Макросы позволяют писать DRY код, путём разделения общих частей функций
и/или набор тестов. Вот пример, который реализует и тестирует операторы
<code>+=</code>, <code>*=</code> и <code>-=</code> на <code>Vec&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // Указатель `tt` (единственное дерево лексем) используют для
    // операторов и лексем.
    ($a:ident, $b: ident, $func:ident, $op:tt) =&gt; (
        assert!($a.len() == $b.len(),
                &quot;{:?}: несоответствие размеров: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    )
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; (
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    )
}

// Реализуем функции `add_assign`, `mul_assign`, и `sub_assign`.
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        }
    }

    // Протестируем `add_assign`, `mul_assign` и `sub_assign`
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
</code></pre></pre>
<pre><code class="language-bash">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<h1><a class="header" href="#domain-specific-languages-dsls" id="domain-specific-languages-dsls">Domain Specific Languages (DSLs)</a></h1>
<p>A DSL is a mini &quot;language&quot; embedded in a Rust macro. It is completely valid
Rust because the macro system expands into normal Rust constructs, but it looks
like a small language. This allows you to define concise or intuitive syntax for
some special functionality (within bounds).</p>
<p>Suppose that I want to define a little calculator API. I would like to supply
an expression an have the output printed to console.</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! calculate {
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // hehehe `eval` is _not_ a Rust keyword!
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<p>Output:</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>This was a very simple example, but much more complex interfaces have been
developed, such as <a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> or
<a href="https://crates.io/crates/clap"><code>clap</code></a>.</p>
<h1><a class="header" href="#variadic-interfaces" id="variadic-interfaces">Variadic Interfaces</a></h1>
<p>A <em>variadic</em> interface takes an arbitrary number of arguments. For example,
<code>println!</code> can take an arbitrary number of arguments, as determined by the
format string.</p>
<p>We can extend our <code>calculate!</code> macro from the previous section to be variadic:</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! calculate {
    // The pattern for a single `eval`
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};

    // Decompose multiple `eval`s recursively
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // Look ma! Variadic `calculate!`!
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<p>Output:</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<h1><a class="header" href="#error-handling" id="error-handling">Error handling</a></h1>
<p>Error handling is the process of handling the possibility of failure. For
example, failing to read a file and then continuing to use that <em>bad</em> input
would clearly be problematic. Noticing and explicitly managing those errors
saves the rest of the program from various pitfalls.</p>
<p>There are various ways to deal with errors in Rust, which are described in the
following subchapters. They all have more or less subtle differences and different
use cases. As a rule of thumb:</p>
<p>An explicit <code>panic</code> is mainly useful for tests and dealing with unrecoverable errors.
For prototyping it can be useful, for example when dealing with functions that
haven't been implemented yet, but in those cases the more descriptive <code>unimplemented</code>
is better. In tests <code>panic</code> is a reasonable way to explicitly fail.</p>
<p>The <code>Option</code> type is for when a value is optional or when the lack of a value is
not an error condition. For example the parent of a directory - <code>/</code> and <code>C:</code> don't
have one. When dealing with <code>Option</code>s, <code>unwrap</code> is fine for prototyping and cases
where it's absolutely certain that there is guaranteed to be a value. However <code>expect</code>
is more useful since it lets you specify an error message in case something goes
wrong anyway.</p>
<p>When there is a chance that things do go wrong and the caller has to deal with the
problem, use <code>Result</code>. You can <code>unwrap</code> and <code>expect</code> them as well (please don't
do that unless it's a test or quick prototype).</p>
<p>For a more rigorous discussion of error handling, refer to the error
handling section in the <a href="https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html">official book</a>.</p>
<h1><a class="header" href="#panic" id="panic"><code>panic</code></a></h1>
<p>Самый простой механизм обработки ошибок, с которым мы познакомимся – это <code>panic</code>.
Он печатает сообщение с ошибкой, начинает процедуру
раскрутки стека и, чаще всего, завершает программу. В данном примере мы явно вызывает <code>panic</code> в случае ошибки:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn give_princess(gift: &amp;str) {
    // Принцесса ненавидит змей, поэтому нам нужно остановиться, если она не одобрит!
    if gift == &quot;змея&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;Я люблю тебя, {}!!!!!&quot;, gift);
}

fn main() {
    give_princess(&quot;плюшевый мишка&quot;);
    give_princess(&quot;змея&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#option--unwrap" id="option--unwrap"><code>Option</code> &amp; <code>unwrap</code></a></h1>
<p>In the last example, we showed that we can induce program failure at will. 
We told our program to <code>panic</code> if the princess received an inappropriate 
gift - a snake. But what if the princess expected a gift and didn't receive 
one? That case would be just as bad, so it needs to be handled!</p>
<p>We <em>could</em> test this against the null string (<code>&quot;&quot;</code>) as we do with a snake. 
Since we're using Rust, let's instead have the compiler point out cases 
where there's no gift.</p>
<p>An <code>enum</code> called <code>Option&lt;T&gt;</code> in the <code>std</code> library is used when absence is a 
possibility. It manifests itself as one of two &quot;options&quot;:</p>
<ul>
<li><code>Some(T)</code>: An element of type <code>T</code> was found</li>
<li><code>None</code>: No element was found</li>
</ul>
<p>These cases can either be explicitly handled via <code>match</code> or implicitly with 
<code>unwrap</code>. Implicit handling will either return the inner element or <code>panic</code>.</p>
<p>Note that it's possible to manually customize <code>panic</code> with <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a>, 
but <code>unwrap</code> otherwise leaves us with a less meaningful output than explicit 
handling. In the following example, explicit handling yields a more 
controlled result while retaining the option to <code>panic</code> if desired.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// The commoner has seen it all, and can handle any gift well.
// All gifts are handled explicitly using `match`.
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // Specify a course of action for each case.
    match gift {
        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I'm throwing that snake in a fire.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),
        None          =&gt; println!(&quot;No gift? Oh well.&quot;),
    }
}

// Our sheltered princess will `panic` at the sight of snakes.
// All gifts are handled implicitly using `unwrap`.
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap` returns a `panic` when it receives a `None`.
    let inside = gift.unwrap();
    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;cabbage&quot;);
    let snake = Some(&quot;snake&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;robin&quot;);
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre></pre>
<h1><a class="header" href="#combinators-map" id="combinators-map">Combinators: <code>map</code></a></h1>
<p><code>match</code> is a valid method for handling <code>Option</code>s. However, you may 
eventually find heavy usage tedious, especially with operations only valid 
with an input. In these cases, <a href="https://doc.rust-lang.org/book/glossary.html#combinators">combinators</a> can be used to 
manage control flow in a modular fashion.</p>
<p><code>Option</code> has a built in method called <code>map()</code>, a combinator for the simple 
mapping of <code>Some -&gt; Some</code> and <code>None -&gt; None</code>. Multiple <code>map()</code> calls can be 
chained together for even more flexibility.</p>
<p>In the following example, <code>process()</code> replaces all functions previous
to it while staying compact.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// Peeling food. If there isn't any, then return `None`.
// Otherwise, return the peeled food.
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// Chopping food. If there isn't any, then return `None`.
// Otherwise, return the chopped food.
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// Cooking food. Here, we showcase `map()` instead of `match` for case handling.
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// A function to peel, chop, and cook food all in sequence.
// We chain multiple uses of `map()` to simplify the code.
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// Check whether there's food or not before trying to eat it!
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking `process()` now.
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-10" id="see-also-10">See also:</a></h3>
<p><a href="error/option_unwrap/fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<h1><a class="header" href="#combinators-and_then" id="combinators-and_then">Combinators: <code>and_then</code></a></h1>
<p><code>map()</code> was described as a chainable way to simplify <code>match</code> statements. 
However, using <code>map()</code> on a function that returns an <code>Option&lt;T&gt;</code> results 
in the nested <code>Option&lt;Option&lt;T&gt;&gt;</code>. Chaining multiple calls together can 
then become confusing. That's where another combinator called <code>and_then()</code>, 
known in some languages as flatmap, comes in.</p>
<p><code>and_then()</code> calls its function input with the wrapped value and returns the result. If the <code>Option</code> is <code>None</code>, then it returns <code>None</code> instead.</p>
<p>In the following example, <code>cookable_v2()</code> results in an <code>Option&lt;Food&gt;</code>. 
Using <code>map()</code> instead of <code>and_then()</code> would have given an 
<code>Option&lt;Option&lt;Food&gt;&gt;</code>, which is an invalid type for <code>eat()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// We don't have the ingredients to make Sushi.
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// We have the recipe for everything except Cordon Bleu.
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// To make a dish, we need both the ingredients and the recipe.
// We can represent the logic with a chain of `match`es:
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_ingredients(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_recipe(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// This can conveniently be rewritten more compactly with `and_then()`:
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_ingredients(food).and_then(have_recipe)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-11" id="see-also-11">See also:</a></h3>
<p><a href="error/option_unwrap/fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, and <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></p>
<h1><a class="header" href="#result" id="result"><code>Result</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> is a richer version of the <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> type that
describes possible <em>error</em> instead of possible <em>absence</em>.</p>
<p>That is, <code>Result&lt;T, E&gt;</code> could have one of two outcomes:</p>
<ul>
<li><code>Ok&lt;T&gt;</code>: An element <code>T</code> was found</li>
<li><code>Err&lt;E&gt;</code>: An error was found with element <code>E</code></li>
</ul>
<p>By convention, the expected outcome is <code>Ok</code> while the unexpected outcome is <code>Err</code>.</p>
<p>Like <code>Option</code>, <code>Result</code> has many methods associated with it. <code>unwrap()</code>, for
example, either yields the element <code>T</code> or <code>panic</code>s. For case handling,
there are many combinators between <code>Result</code> and <code>Option</code> that overlap.</p>
<p>In working with Rust, you will likely encounter methods that return the
<code>Result</code> type, such as the <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a> method. It might not always
be possible to parse a string into the other type, so <code>parse()</code> returns a
<code>Result</code> indicating possible failure.</p>
<p>Let's see what happens when we successfully and unsuccessfully <code>parse()</code> a string:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // Let's try using `unwrap()` to get the number out. Will it bite us?
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<p>In the unsuccessful case, <code>parse()</code> leaves us with an error for <code>unwrap()</code>
to <code>panic</code> on. Additionally, the <code>panic</code> exits our program and provides an
unpleasant error message.</p>
<p>To improve the quality of our error message, we should be more specific
about the return type and consider explicitly handling the error.</p>
<h1><a class="header" href="#map-for-result" id="map-for-result"><code>map</code> for <code>Result</code></a></h1>
<p>Panicking in the previous example's <code>multiply</code> does not make for robust code.
Generally, we want to return the error to the caller so it can decide what is
the right way to respond to errors.</p>
<p>We first need to know what kind of error type we are dealing with. To determine
the <code>Err</code> type, we look to <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>, which is implemented with the
<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait for <a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>. As a result, the <code>Err</code> type is
specified as <a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>.</p>
<p>In the example below, the straightforward <code>match</code> statement leads to code
that is overall more cumbersome.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// With the return type rewritten, we use pattern matching without `unwrap()`.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<p>Luckily, <code>Option</code>'s <code>map</code>, <code>and_then</code>, and many other combinators are also
implemented for <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> contains a complete listing.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// As with `Option`, we can use combinators such as `map()`.
// This function is otherwise identical to the one above and reads:
// Modify n if the value is valid, otherwise pass on the error.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<h1><a class="header" href="#Псевдонимы-для-result" id="Псевдонимы-для-result">Псевдонимы для <code>Result</code></a></h1>
<p>Как насчёт случая, когда мы хотим использовать конкретный тип <code>Result</code> много раз?
Напомним, что Rust позволяет нам создавать <a href="error/result/types/alias.html">псевдонимы</a>. Мы можем
удобно объявить псевдоним для конкретного <code>Result</code>.</p>
<p>Особенно полезным может быть создание псевдонимов на уровне модулей. Ошибки,
найденные в конкретном модуле, часто имеют один и тот же тип <code>Err</code>, поэтому один
псевдоним может лаконично объявить <em>все</em> ассоциированные <code>Results</code>.
Это настолько полезно, что библиотека <code>std</code> обеспечивает даже один: <code>io::Result</code>!</p>
<p>Ниже приведён краткий пример для демонстрации синтаксиса:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// Объявим обобщённый псевдоним для `Result` с типом ошибки `ParseIntError`.
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// Используем вышеуказанный псевдоним для обозначения
// нашего конкретного типа `Result`.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// Здесь псевдоним снова позволяет нам сэкономить место.
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n это {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-46" id="Смотрите-также-46">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<h1><a class="header" href="#early-returns" id="early-returns">Early returns</a></h1>
<p>In the previous example, we explicitly handled the errors using combinators.
Another way to deal with this case analysis is to use a combination of
<code>match</code> statements and <em>early returns</em>.</p>
<p>That is, we can simply stop executing the function and return the error if
one occurs. For some, this form of code can be easier to both read and
write. Consider this version of the previous example, rewritten using early returns:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<p>At this point, we've learned to explicitly handle errors using combinators
and early returns. While we generally want to avoid panicking, explicitly
handling all of our errors is cumbersome.</p>
<p>In the next section, we'll introduce <code>?</code> for the cases where we simply
need to <code>unwrap</code> without possibly inducing <code>panic</code>.</p>
<h1><a class="header" href="#introducing-" id="introducing-">Introducing <code>?</code></a></h1>
<p>Sometimes we just want the simplicity of <code>unwrap</code> without the possibility of
a <code>panic</code>. Until now, <code>unwrap</code> has forced us to nest deeper and deeper when
what we really wanted was to get the variable <em>out</em>. This is exactly the purpose of <code>?</code>.</p>
<p>Upon finding an <code>Err</code>, there are two valid actions to take:</p>
<ol>
<li><code>panic!</code> which we already decided to try to avoid if possible</li>
<li><code>return</code> because an <code>Err</code> means it cannot be handled</li>
</ol>
<p><code>?</code> is <em>almost</em><sup class="footnote-reference"><a href="#†">1</a></sup> exactly equivalent to an <code>unwrap</code> which <code>return</code>s
instead of <code>panic</code>s on <code>Err</code>s. Let's see how we can simplify the earlier
example that used combinators:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h2><a class="header" href="#the-try-macro" id="the-try-macro">The <code>try!</code> macro</a></h2>
<p>Before there was <code>?</code>, the same functionality was achieved with the <code>try!</code> macro.
The <code>?</code> operator is now recommended, but you may still find <code>try!</code> when looking
at older code. The same <code>multiply</code> function from the previous example
would look like this using <code>try!</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>See <a href="error/result/error/multiple_error_types/reenter_question_mark.html">re-enter ?</a> for more details.</p>
</div>
<h1><a class="header" href="#multiple-error-types" id="multiple-error-types">Multiple error types</a></h1>
<p>The previous examples have always been very convenient; <code>Result</code>s interact
with other <code>Result</code>s and <code>Option</code>s interact with other <code>Option</code>s.</p>
<p>Sometimes an <code>Option</code> needs to interact with a <code>Result</code>, or a
<code>Result&lt;T, Error1&gt;</code> needs to interact with a <code>Result&lt;T, Error2&gt;</code>. In those
cases, we want to manage our different error types in a way that makes them
composable and easy to interact with.</p>
<p>In the following code, two instances of <code>unwrap</code> generate different error
types. <code>Vec::first</code> returns an <code>Option</code>, while <code>parse::&lt;i32&gt;</code> returns a
<code>Result&lt;i32, ParseIntError&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Generate error 1
    2 * first.parse::&lt;i32&gt;().unwrap() // Generate error 2
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>Over the next sections, we'll see several strategies for handling these kind of problems.</p>
<h1><a class="header" href="#pulling-results-out-of-options" id="pulling-results-out-of-options">Pulling <code>Result</code>s out of <code>Option</code>s</a></h1>
<p>The most basic way of handling mixed error types is to just embed them in each
other.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>There are times when we'll want to stop processing on errors (like with
<a href="error/multiple_error_types/error/result/enter_question_mark.html"><code>?</code></a>) but keep going when the <code>Option</code> is <code>None</code>. A
couple of combinators come in handy to swap the <code>Result</code> and <code>Option</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    let opt = opt.map_or(Ok(None), |r| r.map(Some))?;

    Ok(opt)
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));
    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#defining-an-error-type" id="defining-an-error-type">Defining an error type</a></h1>
<p>Sometimes it simplifies the code to mask all of the different errors with a
single type of error.  We'll show this with a custom error.</p>
<p>Rust allows us to define our own error types. In general, a &quot;good&quot; error type:</p>
<ul>
<li>Represents different errors with the same type</li>
<li>Presents nice error messages to the user</li>
<li>Is easy to compare with other types
<ul>
<li>Good: <code>Err(EmptyVec)</code></li>
<li>Bad: <code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>Can hold information about the error
<ul>
<li>Good: <code>Err(BadChar(c, position))</code></li>
<li>Bad: <code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>Composes well with other errors</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;
use std::num::ParseIntError;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug, Clone)]
// Define our error types. These may be customized for our error handling cases.
// Now we will be able to write our own errors, defer to an underlying error
// implementation, or do something in between.
struct DoubleError;

// Generation of an error is completely separate from how it is displayed.
// There's no need to be concerned about cluttering complex logic with the display style.
//
// Note that we don't store any extra info about the errors. This means we can't state
// which string failed to parse without modifying our types to carry that information.
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

// This is important for other errors to wrap this one.
impl error::Error for DoubleError {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        // Generic error, underlying cause isn't tracked.
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       // Change the error to our new type.
       .ok_or(DoubleError)
       .and_then(|s| s.parse::&lt;i32&gt;()
            // Update to the new error type here also.
            .map_err(|_| DoubleError)
            .map(|i| 2 * i))
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#boxing-errors" id="boxing-errors"><code>Box</code>ing errors</a></h1>
<p>A way to write simple code while preserving the original errors is to <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>
them.  The drawback is that the underlying error type is only known at runtime and not
<a href="https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">statically determined</a>.</p>
<p>The stdlib helps in boxing our errors by having <code>Box</code> implement conversion from
any type that implements the <code>Error</code> trait into the trait object <code>Box&lt;Error&gt;</code>,
via <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;
use std::num::ParseIntError;

// Change the alias to `Box&lt;error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        // Generic error, underlying cause isn't tracked.
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       .ok_or_else(|| EmptyVec.into())  // Converts to Box
       .and_then(|s| s.parse::&lt;i32&gt;()
            .map_err(|e| e.into())  // Converts to Box
            .map(|i| 2 * i))
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-12" id="see-also-12">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">Dynamic dispatch</a> and <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> trait</a></p>
<h1><a class="header" href="#other-uses-of-" id="other-uses-of-">Other uses of <code>?</code></a></h1>
<p>Notice in the previous example that our immediate reaction to calling
<code>parse</code> is to <code>map</code> the error from a library error into a boxed
error:</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
</code></pre>
<p>Since this is a simple and common operation, it would be convenient if it
could be elided. Alas, because <code>and_then</code> is not sufficiently flexible, it
cannot. However, we can instead use <code>?</code>.</p>
<p><code>?</code> was previously explained as either <code>unwrap</code> or <code>return Err(err)</code>.
This is only mostly true. It actually means <code>unwrap</code> or
<code>return Err(From::from(err))</code>. Since <code>From::from</code> is a conversion utility
between different types, this means that if you <code>?</code> where the error is
convertible to the return type, it will convert automatically.</p>
<p>Here, we rewrite the previous example using <code>?</code>. As a result, the
<code>map_err</code> will go away when <code>From::from</code> is implemented for our error type:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;
use std::num::ParseIntError;

// Change the alias to `Box&lt;error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        // Generic error, underlying cause isn't tracked.
        None
    }
}

// The same structure as before but rather than chain all `Results`
// and `Options` along, we `?` to get the inner value out immediately.
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>This is actually fairly clean now. Compared with the original <code>panic</code>, it
is very similar to replacing the <code>unwrap</code> calls with <code>?</code> except that the
return types are <code>Result</code>. As a result, they must be destructured at the
top level.</p>
<h3><a class="header" href="#see-also-13" id="see-also-13">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the--operator"><code>?</code></a></p>
<h1><a class="header" href="#wrapping-errors" id="wrapping-errors">Wrapping errors</a></h1>
<p>An alternative to boxing errors is to wrap them in your own error type.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // We will defer to the parse error implementation for their error.
    // Supplying extra info requires adding more data to the type.
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // This is a wrapper, so defer to the underlying types' implementation of `fmt`.
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn description(&amp;self) -&gt; &amp;str {
        match *self {
            DoubleError::EmptyVec =&gt; &quot;empty vectors not allowed&quot;,
            // This already impls `Error`, so defer to its own implementation.
            DoubleError::Parse(ref e) =&gt; e.description(),
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // The cause is the underlying implementation error type. Is implicitly
            // cast to the trait object `&amp;error::Error`. This works because the
            // underlying type already implements the `Error` trait.
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// Implement the conversion from `ParseIntError` to `DoubleError`.
// This will be automatically called by `?` if a `ParseIntError`
// needs to be converted into a `DoubleError`.
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>This adds a bit more boilerplate for handling errors and might not be needed in
all applications. There are some libraries that can take care of the boilerplate
for you.</p>
<h3><a class="header" href="#see-also-14" id="see-also-14">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="error/multiple_error_types/custom_types/enum.html"><code>Enums</code></a></p>
<h1><a class="header" href="#iterating-over-results" id="iterating-over-results">Iterating over <code>Result</code>s</a></h1>
<p>An <code>Iter::map</code> operation might fail, for example:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let possible_numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, possible_numbers);
}
</code></pre></pre>
<p>Let's step through strategies for handling this.</p>
<h2><a class="header" href="#ignore-the-failed-items-with-filter_map" id="ignore-the-failed-items-with-filter_map">Ignore the failed items with <code>filter_map()</code></a></h2>
<p><code>filter_map</code> calls a function and filters out the results that are <code>None</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .filter_map(Result::ok)
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<h2><a class="header" href="#fail-the-entire-operation-with-collect" id="fail-the-entire-operation-with-collect">Fail the entire operation with <code>collect()</code></a></h2>
<p><code>Result</code> implements <code>FromIter</code> so that a vector of results (<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)
can be turned into a result with a vector (<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>). Once an
<code>Result::Err</code> is found, the iteration will terminate.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>This same technique can be used with <code>Option</code>.</p>
<h2><a class="header" href="#collect-all-valid-values-and-failures-with-partition" id="collect-all-valid-values-and-failures-with-partition">Collect all valid values and failures with <code>partition()</code></a></h2>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<p>When you look at the results, you'll note that everything is still wrapped in
<code>Result</code>.  A little more boilerplate is needed for this.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<h1><a class="header" href="#Типы-стандартной-библиотеки" id="Типы-стандартной-библиотеки">Типы стандартной библиотеки</a></h1>
<p>Стандартная библиотека <code>std</code> предоставляет множество пользовательских типов, которые значительно
расширяют на <code>примитивах</code>. Некоторые из них содержат:</p>
<ul>
<li>расширяемую строку <code>String</code>s: <code>&quot;hello world&quot;</code></li>
<li>динамический массив: <code>[1, 2, 3]</code></li>
<li>опциональные типы: <code>Option&lt;i32&gt;</code></li>
<li>типы для обработки ошибок: <code>Result&lt;i32, i32&gt;</code></li>
<li>указатели на объекты в куче: <code>Box&lt;i32&gt;</code></li>
</ul>
<h3><a class="header" href="#Смотрите-также-47" id="Смотрите-также-47">Смотрите также:</a></h3>
<p><a href="primitives.html">Примитивы</a> и <a href="https://doc.rust-lang.org/std/">стандартная библиотека std</a></p>
<h1><a class="header" href="#box-стек-и-куча" id="box-стек-и-куча"><code>Box</code>, стек и куча</a></h1>
<p>Все значения в Rust по умолчанию аллоцируются на стеке. Значения могут быть <em>упакованы</em>
(аллоцированы в куче) при помощи создания <code>Box&lt;T&gt;</code>. <code>Box</code> - это умный указатель на аллоцированное в куче значение типа <code>T</code>. Когда <code>Box</code> покидает область видимости, вызывается его деструктор, который уничтожает внутренний объект, и занятая им память в куче освобождается.</p>
<p>Упакованные значения могут быть разыменованы с помощью операции <code>*</code>.
Эта операция убирает один уровень косвенности.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // Аллоцировать эту точку в куче и вернуть указатель на неё
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // (все аннотации типов избыточны)
    // Переменные, аллоцированные на стеке
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        p1: origin(),
        p2: Point { x: 3.0, y: 4.0 }
    };

    // Прямоугольник, аллоцированный в куче
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        p1: origin(),
        p2: origin()
    });

    // Результат функции может быть упакован
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // Двойная косвенность
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Точка занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Прямоугольник занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;rectangle));

    // box size == pointer size
    println!(&quot;Упакованная точка занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Упакованный прямоугольник занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Упакованная 'упаковка' занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // Копируем данные из `boxed_point` в `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Распакованная точка занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<h1><a class="header" href="#Вектора" id="Вектора">Вектора</a></h1>
<p>Вектора — это массивы с изменяемым размером. Как и у срезов, их размер не
известен при компиляции, но он может увеличиваться и уменьшаться в любое время.
Вектор определяется тремя словами: указатель на данные, длина вектора и
его ёмкость. Ёмкость определяет, сколько памяти резервируется для вектора.
Вектор может увеличиваться, пока его длина меньше его ёмкости. При необходимости
превысить заданное значение объёма, вектору повторно выделяется память большего
объёма.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Итераторы можно собрать в вектора
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Собираем (0..10) в: {:?}&quot;, collected_iterator);

    // Для инициализации вектора можно использовать макрос `vec!`
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Начальный вектор: {:?}&quot;, xs);

    // Вставляет новый элемент в конце вектора
    println!(&quot;Добавляем четвёртый элемент в вектор&quot;);
    xs.push(4);
    println!(&quot;Вектор: {:?}&quot;, xs);

    // Ошибка! Неизменяемые вектора не могут увеличиваться
    collected_iterator.push(0);
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку

    // Метод `len` возвращает текущий размер вектора
    println!(&quot;Размер вектора: {}&quot;, xs.len());

    // Обращение к элементам вектора записывается с помощью квадратных скобок
    // (нумерация элементов начинается с 0)
    println!(&quot;Второй элемент: {}&quot;, xs[1]);

    // `pop` удаляет последний элемент из вектора и возвращает его
    println!(&quot;Удаляем последний элемент: {:?}&quot;, xs.pop());

    // Обращение к элементу за пределами вектора вызывает ошибку
    println!(&quot;Четвёртый элемент: {}&quot;, xs[3]);

    // По вектору можно легко итерироваться
    println!(&quot;xs состоит из:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // К итератору вектора можно применить адаптер `enumerate`,
    // число итераций хранится в переменной (`i`)
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // Благодаря методу `iter_mut`, можно обойти вектор
    // при этом изменить каждое значение в нем.
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Обновленный вектор: {:?}&quot;, xs);
}
</code></pre></pre>
<p>Подробную информацию о методах объекта <code>Vec</code>
можно почитать в разделе модуля <a href="https://doc.rust-lang.org/std/vec/">std::vec</a></p>
<h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<p>There are two types of strings in Rust: <code>String</code> and <code>&amp;str</code>.</p>
<p>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to
always be a valid UTF-8 sequence. <code>String</code> is heap allocated, growable and not
null terminated.</p>
<p><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and
can be used to view into a <code>String</code>, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // (all the type annotations are superfluous)
    // A reference to a string allocated in read only memory
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // Iterate over words in reverse, no new string is allocated
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Copy chars into a vector, sort and remove duplicates
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Create an empty and growable `String`
    let mut string = String::new();
    for c in chars {
        // Insert a char at the end of string
        string.push(c);
        // Insert a string at the end of string
        string.push_str(&quot;, &quot;);
    }

    // The trimmed string is a slice to the original string, hence no new
    // allocation is performed
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // Heap allocate a string
    let alice = String::from(&quot;I like dogs&quot;);
    // Allocate new memory and store the modified string there
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>More <code>str</code>/<code>String</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/str/">std::str</a> and
<a href="https://doc.rust-lang.org/std/string/">std::string</a>
modules</p>
<h2><a class="header" href="#literals-and-escapes" id="literals-and-escapes">Literals and escapes</a></h2>
<p>There are multiple ways to write string literals with special characters in them.
All result in a similar <code>&amp;str</code> so it's best to use the form that is the most
convenient to write. Similarly there are multiple ways to write byte string literals,
which all result in <code>&amp;[u8; N]</code>.</p>
<p>Generally special characters are escaped with a backslash character: <code></code>.
This way you can add any character to your string, even unprintable ones
and ones that you don't know how to type. If you want a literal backslash,
escape it with another one: <code>\</code></p>
<p>String or character literal delimiters occuring within a literal must be escaped: <code>&quot;\&quot;&quot;</code>, <code>'\''</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>Sometimes there are just too many characters that need to be escaped or it's just
much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>Want a string that's not UTF-8? (Remember, <code>str</code> and <code>String</code> must be valid UTF-8)
Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::str;

fn main() {
    // Note that this is not actually a &amp;str
    let bytestring: &amp;[u8; 20] = b&quot;this is a bytestring&quot;;

    // Byte arrays don't have Display so printing them is a bit limited
    println!(&quot;A bytestring: {:?}&quot;, bytestring);

    // Bytestrings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw bytestrings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to str can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Bytestrings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // &quot;ようこそ&quot; in SHIFT-JIS

    // But then they can't always be converted to str
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>For conversions between character encodings check out the <a href="https://crates.io/crates/encoding">encoding</a> crate.</p>
<p>A more detailed listing of the ways to write string literals and escape characters
is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>
<h1><a class="header" href="#option" id="option"><code>Option</code></a></h1>
<p>Иногда желательно перехватить ошибку в какой-либо части программы
вместо вызова паники с помощью макроса <code>panic!</code>. Это можно сделать
с помощью перечисления <code>Option</code>.</p>
<p>Перечисление <code>Option&lt;T&gt;</code> имеет два варианта:</p>
<ul>
<li><code>None</code>, указывающий о наличии ошибки или отсутствия значений</li>
<li><code>Some(value)</code>, кортежная структура, обёртка для <code>значения</code> типа <code>T</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Целочисленное деление, которое не вызывает `panic!`
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // В случае ошибки возвращаем `None`
        None
    } else {
        // Результат деления возвращаем в варианте `Some`
        Some(dividend / divisor)
    }
}

// Эта функция обрабатывает деление, которое может выполнится с ошибкой
fn try_division(dividend: i32, divisor: i32) {
    // Значение типа `Option` могут быть сопоставлены по шаблону
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} вызвало ошибку!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // Привязка `None` к переменной должна быть аннотированной по типу
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // Распаковка варианта `Some` будет извлекать данные, которые в нем находятся.
    println!(&quot;{:?} распаковывается в {:?}&quot;, optional_float, optional_float.unwrap());

    // Распаковка варианта `None` вызовет `panic!`
    println!(&quot;{:?} распаковывается в {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<h1><a class="header" href="#result-1" id="result-1"><code>Result</code></a></h1>
<p>We've seen that the <code>Option</code> enum can be used as a return value from functions
that may fail, where <code>None</code> can be returned to indicate failure. However,
sometimes it is important to express <em>why</em> an operation failed. To do this we 
have the <code>Result</code> enum.</p>
<p>The <code>Result&lt;T, E&gt;</code> enum has two variants:</p>
<ul>
<li><code>Ok(value)</code> which indicates that the operation succeeded, and wraps the
<code>value</code> returned by the operation. (<code>value</code> has type <code>T</code>)</li>
<li><code>Err(why)</code>, which indicates that the operation failed, and wraps <code>why</code>,
which (hopefully) explains the cause of the failure. (<code>why</code> has type <code>E</code>)</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    // Mathematical &quot;errors&quot; we want to catch
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // This operation would `fail`, instead let's return the reason of
            // the failure wrapped in `Err`
            Err(MathError::DivisionByZero)
        } else {
            // This operation is valid, return the result wrapped in `Ok`
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // This is a three level match pyramid!
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // Will this fail?
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<h1><a class="header" href="#" id=""><code>?</code></a></h1>
<p>Chaining results using match can get pretty untidy; luckily, the <code>?</code> operator
can be used to make things pretty again. <code>?</code> is used at the end of an expression
returning a <code>Result</code>, and is equivalent to a match expression, where the 
<code>Err(err)</code> branch expands to an early <code>Err(From::from(err))</code>, and the <code>Ok(ok)</code>
branch expands to an <code>ok</code> expression.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // Intermediate function
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // if `div` &quot;fails&quot;, then `DivisionByZero` will be `return`ed
        let ratio = div(x, y)?;

        // if `ln` &quot;fails&quot;, then `NonPositiveLogarithm` will be `return`ed
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(match why {
                MathError::NonPositiveLogarithm
                    =&gt; &quot;logarithm of non-positive number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>Be sure to check the <a href="https://doc.rust-lang.org/std/result/index.html">documentation</a>,
as there are many methods to map/compose <code>Result</code>.</p>
<h1><a class="header" href="#panic-1" id="panic-1"><code>panic!</code></a></h1>
<p>Макрос <code>panic!</code> используется для генерации паники и раскрутки стека.
Во время раскрутки стека, среда выполнения возьмёт на себя всю ответственность по
освобождению ресурсов, которыми <em>владеет</em> текущий поток, вызывая деструкторы
всех объектов.</p>
<p>Так как в данном случае мы имеем дело с однопоточной программой, <code>panic!</code> заставит
программу вывести сообщение с ошибкой и завершится.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Реализуем свою версию целочисленного деления (/)
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
       // Деление на ноль вызывает панику
        panic!(&quot;Деление на ноль!&quot;);
    } else {
        dividend / divisor
    }
}

// Основной поток `main`
fn main() {
    // Целочисленное значение, выделенное в куче
    let _x = Box::new(0i32);

    // Это операция вызовет панику в основном потоке
    division(3, 0);

    println!(&quot;Эта часть кода не будет достигнута&quot;);

    // `_x` должен быть уничтожен в этой точке
}
</code></pre></pre>
<p>Давайте убедимся, что <code>panic!</code> не приводит к утечки памяти.</p>
<pre><code class="language-bash">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<h1><a class="header" href="#hashmap" id="hashmap">HashMap</a></h1>
<p>Where vectors store values by an integer index, <code>HashMap</code>s store values by key. 
<code>HashMap</code> keys can be booleans, integers, strings, 
or any other type that implements the <code>Eq</code> and <code>Hash</code> traits. 
More on this in the next section.</p>
<p>Like vectors, <code>HashMap</code>s are growable, but HashMaps can also shrink themselves 
when they have excess space. 
You can create a HashMap with a certain starting capacity using 
<code>HashMap::with_capacity(uint)</code>, or use <code>HashMap::new()</code> to get a HashMap 
with a default initial capacity (recommended).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // Takes a reference and returns Option&lt;&amp;V&gt;
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // `HashMap::insert()` returns `None`
    // if the inserted value is new, `Some(value)` otherwise
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;&quot;Ashley&quot;); 

    // `HashMap::iter()` returns an iterator that yields 
    // (&amp;'a key, &amp;'a value) pairs in arbitrary order.
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>For more information on how hashing and hash maps 
(sometimes called hash tables) work, have a look at 
<a href="https://en.wikipedia.org/wiki/Hash_table">Hash Table Wikipedia</a></p>
<h1><a class="header" href="#alternatecustom-key-types" id="alternatecustom-key-types">Alternate/custom key types</a></h1>
<p>Any type that implements the <code>Eq</code> and <code>Hash</code> traits can be a key in <code>HashMap</code>. 
This includes:</p>
<ul>
<li><code>bool</code> (though not very useful since there is only two possible keys)</li>
<li><code>int</code>, <code>uint</code>, and all variations thereof</li>
<li><code>String</code> and <code>&amp;str</code> (protip: you can have a <code>HashMap</code> keyed by <code>String</code>
and call <code>.get()</code> with an <code>&amp;str</code>)</li>
</ul>
<p>Note that <code>f32</code> and <code>f64</code> do <em>not</em> implement <code>Hash</code>,
likely because <a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">floating-point precision errors</a>
would make using them as hashmap keys horribly error-prone.</p>
<p>All collection classes implement <code>Eq</code> and <code>Hash</code> 
if their contained type also respectively implements <code>Eq</code> and <code>Hash</code>. 
For example, <code>Vec&lt;T&gt;</code> will implement <code>Hash</code> if <code>T</code> implements <code>Hash</code>.</p>
<p>You can easily implement <code>Eq</code> and <code>Hash</code> for a custom type with just one line: 
<code>#[derive(PartialEq, Eq, Hash)]</code></p>
<p>The compiler will do the rest. If you want more control over the details, 
you can implement <code>Eq</code> and/or <code>Hash</code> yourself. 
This guide will not cover the specifics of implementing <code>Hash</code>. </p>
<p>To play around with using a <code>struct</code> in <code>HashMap</code>, 
let's try making a very simple user logon system:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

// Eq requires that you derive PartialEq on the type.
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username: username,
        password: password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#hashset" id="hashset">HashSet</a></h1>
<p>Consider a <code>HashSet</code> as a <code>HashMap</code> where we just care about the keys (
<code>HashSet&lt;T&gt;</code> is, in actuality, just a wrapper around <code>HashMap&lt;T, ()&gt;</code>).</p>
<p>&quot;What's the point of that?&quot; you ask. &quot;I could just store the keys in a <code>Vec</code>.&quot;</p>
<p>A <code>HashSet</code>'s unique feature is that 
it is guaranteed to not have duplicate elements. 
That's the contract that any set collection fulfills. 
<code>HashSet</code> is just one implementation. (see also: <a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>)</p>
<p>If you insert a value that is already present in the <code>HashSet</code>, 
(i.e. the new value is equal to the existing and they both have the same hash), 
then the new value will replace the old.</p>
<p>This is great for when you never want more than one of something, 
or when you want to know if you've already got something.</p>
<p>But sets can do more than that. </p>
<p>Sets have 4 primary operations (all of the following calls return an iterator):</p>
<ul>
<li>
<p><code>union</code>: get all the unique elements in both sets.</p>
</li>
<li>
<p><code>difference</code>: get all the elements that are in the first set but not the second.</p>
</li>
<li>
<p><code>intersection</code>: get all the elements that are only in <em>both</em> sets.</p>
</li>
<li>
<p><code>symmetric_difference</code>: 
get all the elements that are in one set or the other, but <em>not</em> both.</p>
</li>
</ul>
<p>Try all of these in the following example:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // `HashSet::insert()` returns false if
    // there was a value already present.
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);
    // FIXME ^ Comment out this line

    b.insert(5);

    // If a collection's element type implements `Debug`,
    // then the collection implements `Debug`.
    // It usually prints its elements in the format `[elem1, elem2, ...]`
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // Print [1, 2, 3, 4, 5] in arbitrary order
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // This should print [1]
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [2, 3, 4] in arbitrary order.
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [1, 5]
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<p>(Examples are adapted from the <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference">documentation.</a>)</p>
<h1><a class="header" href="#Разное-в-стандартной-библиотеке" id="Разное-в-стандартной-библиотеке">Разное в стандартной библиотеке</a></h1>
<p>Многие другие типы предоставляются стандартной библиотекой
для вспомогательных целей, например:</p>
<ul>
<li>Потоки</li>
<li>Каналы</li>
<li>Файловые операции Ввода/Вывода</li>
</ul>
<p>Они расширяют возможности, которые предоставляют <a href="primitives.html">примитивы</a>.</p>
<h3><a class="header" href="#Смотрите-также-48" id="Смотрите-также-48">Смотрите также:</a></h3>
<p><a href="primitives.html">примитивы</a> и <a href="https://doc.rust-lang.org/std/">стандартная библиотека</a></p>
<h1><a class="header" href="#Потоки" id="Потоки">Потоки</a></h1>
<p>В Rust имеется механизм для запуска потоков ОС посредством функции <code>scoped</code>,
которая принимает перемещающее окружение замыкания в качестве аргумента.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

static NTHREADS: i32 = 10;

// Это основной поток `main`
fn main() {
    // Создадим вектор, в котором будет хранить созданные потоки.
    let mut children = vec![];

    for i in 0..NTHREADS {
        // Запустить ещё один поток
        children.push(thread::spawn(move || {
            println!(&quot;Это поток под номером  {}&quot;, i)
        }));
    }

    for child in children {
        // Ждём завершения работы потока. Возвращаем результат.
        let _ = child.join();
    }
}
</code></pre></pre>
<p>Эти потоки управляются ОС.</p>
<h1><a class="header" href="#testcase-map-reduce" id="testcase-map-reduce">Testcase: map-reduce</a></h1>
<p>Rust makes it very easy to parallelise data processing, without many of the headaches traditionally associated with such an attempt.</p>
<p>The standard library provides great threading primitives out of the box.
These, combined with Rust's concept of Ownership and aliasing rules, automatically prevent
data races.</p>
<p>The aliasing rules (one writable reference XOR many readable references) automatically prevent
you from manipulating state that is visible to other threads. (Where synchronisation is needed,
there are synchronisation
primitives like <code>Mutex</code>es or <code>Channel</code>s.)</p>
<p>In this example, we will calculate the sum of all digits in a block of numbers.
We will do this by parcelling out chunks of the block into different threads. Each thread will sum
its tiny block of digits, and subsequently we will sum the intermediate sums produced by each
thread.</p>
<p>Note that, although we're passing references across thread boundaries, Rust understands that we're
only passing read-only references, and that thus no unsafety or data races can occur. Because
we're <code>move</code>-ing the data segments into the thread, Rust will also ensure the data is kept alive
until the threads exit, so no dangling pointers occur.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

// This is the `main` thread
fn main() {

    // This is our data to process.
    // We will calculate the sum of all digits via a threaded  map-reduce algorithm.
    // Each whitespace separated chunk will be handled in a different thread.
    //
    // TODO: see what happens to the output if you insert spaces!
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // Make a vector to hold the child-threads which we will spawn.
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; phase
     *
     * Divide our data into segments, and apply initial processing
     ************************************************************************/

    // split our data into segments for individual calculation
    // each chunk will be a reference (&amp;str) into the actual data
    let chunked_data = data.split_whitespace();

    // Iterate over the data segments.
    // .enumerate() adds the current loop index to whatever is iterated
    // the resulting tuple &quot;(index, element)&quot; is then immediately
    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a
    // &quot;destructuring assignment&quot;
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // Process each data segment in a separate thread
        //
        // spawn() returns a handle to the new thread,
        // which we MUST keep to access the returned value
        //
        // 'move || -&gt; u32' is syntax for a closure that:
        // * takes no arguments ('||')
        // * takes ownership of its captured variables ('move') and
        // * returns an unsigned 32-bit integer ('-&gt; u32')
        //
        // Rust is smart enough to infer the '-&gt; u32' from
        // the closure itself so we could have left that out.
        //
        // TODO: try removing the 'move' and see what happens
        children.push(thread::spawn(move || -&gt; u32 {
            // Calculate the intermediate sum of this segment:
            let result = data_segment
                        // iterate over the characters of our segment..
                        .chars()
                        // .. convert text-characters to their number value..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // .. and sum the resulting iterator of numbers
                        .sum();

            // println! locks stdout, so no text-interleaving occurs
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the
            // last evaluated expression in each block is automatically its value.
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; phase
     *
     * Collect our intermediate results, and combine them into a final result
     ************************************************************************/

    // collect each thread's intermediate results into a new Vec
    let mut intermediate_sums = vec![];
    for child in children {
        // collect each child thread's return-value
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // combine all intermediate sums into a single final sum.
    //
    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint.
    //
    // TODO: try without the turbofish, by instead explicitly
    // specifying the type of final_result
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<h3><a class="header" href="#assignments" id="assignments">Assignments</a></h3>
<p>It is not wise to let our number of threads depend on user inputted data.
What if the user decides to insert a lot of spaces? Do we <em>really</em> want to spawn 2,000 threads?
Modify the program so that the data is always chunked into a limited number of chunks,
defined by a static constant at the beginning of the program.</p>
<h3><a class="header" href="#see-also-15" id="see-also-15">See also:</a></h3>
<ul>
<li><a href="std_misc/threads/std_misc/threads.html">Threads</a></li>
<li><a href="std_misc/threads/std/vec.html">vectors</a> and <a href="std_misc/threads/trait/iter.html">iterators</a></li>
<li><a href="std_misc/threads/fn/closures.html">closures</a>, <a href="std_misc/threads/scope/move.html">move</a> semantics and <a href="https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html#closures-can-capture-their-environment"><code>move</code> closures</a></li>
<li><a href="https://doc.rust-lang.org/book/second-edition/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">destructuring</a> assignments</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish notation</a> to help type inference</li>
<li><a href="std_misc/threads/error/option_unwrap.html">unwrap vs. expect</a></li>
<li><a href="https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></li>
</ul>
<h1><a class="header" href="#channels" id="channels">Channels</a></h1>
<p>Rust provides asynchronous <code>channels</code> for communication between threads. Channels
allow a unidirectional flow of information between two end-points: the
<code>Sender</code> and the <code>Receiver</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Channels have two endpoints: the `Sender&lt;T&gt;` and the `Receiver&lt;T&gt;`,
    // where `T` is the type of the message to be transferred
    // (type annotation is superfluous)
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();

    for id in 0..NTHREADS {
        // The sender endpoint can be copied
        let thread_tx = tx.clone();

        // Each thread will send its id via the channel
        thread::spawn(move || {
            // The thread takes ownership over `thread_tx`
            // Each thread queues a message in the channel
            thread_tx.send(id).unwrap();

            // Sending is a non-blocking operation, the thread will continue
            // immediately after sending its message
            println!(&quot;thread {} finished&quot;, id);
        });
    }

    // Here, all the messages are collected
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // The `recv` method picks a message from the channel
        // `recv` will block the current thread if there are no messages available
        ids.push(rx.recv());
    }

    // Show the order in which the messages were sent
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<h1><a class="header" href="#path" id="path">Path</a></h1>
<p>The <code>Path</code> struct represents file paths in the underlying filesystem. There are
two flavors of <code>Path</code>: <code>posix::Path</code>, for UNIX-like systems, and
<code>windows::Path</code>, for Windows. The prelude exports the appropriate
platform-specific <code>Path</code> variant.</p>
<p>A <code>Path</code> can be created from an <code>OsStr</code>, and provides several methods to get
information from the file/directory the path points to.</p>
<p>Note that a <code>Path</code> is <em>not</em> internally represented as an UTF-8 string, but
instead is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>). Therefore, converting a
<code>Path</code> to a <code>&amp;str</code> is <em>not</em> free and may fail (an <code>Option</code> is returned).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::path::Path;

fn main() {
    // Create a `Path` from an `&amp;'static str`
    let path = Path::new(&quot;.&quot;);

    // The `display` method returns a `Show`able structure
    let _display = path.display();

    // `join` merges a path with a byte container using the OS specific
    // separator, and returns the new path
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // Convert the path into a string slice
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }
}

</code></pre></pre>
<p>Be sure to check at other <code>Path</code> methods (<code>posix::Path</code> or <code>windows::Path</code>) and
the <code>Metadata</code> struct.</p>
<h3><a class="header" href="#see-also-16" id="see-also-16">See also</a></h3>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> and <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html">Metadata</a>.</p>
<h1><a class="header" href="#file-io" id="file-io">File I/O</a></h1>
<p>The <code>File</code> struct represents a file that has been opened (it wraps a file
descriptor), and gives read and/or write access to the underlying file.</p>
<p>Since many things can go wrong when doing file I/O, all the <code>File</code> methods
return the <code>io::Result&lt;T&gt;</code> type, which is an alias for <code>Result&lt;T, io::Error&gt;</code>.</p>
<p>This makes the failure of all I/O operations <em>explicit</em>. Thanks to this, the
programmer can see all the failure paths, and is encouraged to handle them in
a proactive manner.</p>
<h1><a class="header" href="#open" id="open"><code>open</code></a></h1>
<p>The <code>open</code> static method can be used to open a file in read-only mode.</p>
<p>A <code>File</code> owns a resource, the file descriptor and takes care of closing the
file when it is <code>drop</code>ed.</p>
<pre><code class="language-rust editable ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Create a path to the desired file
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // Open the path in read-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        // The `description` method of `io::Error` returns a string that
        // describes the error
        Err(why) =&gt; panic!(&quot;couldn't open {}: {}&quot;, display,
                                                   why.description()),
        Ok(file) =&gt; file,
    };

    // Read the file contents into a string, returns `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {}&quot;, display,
                                                   why.description()),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }

    // `file` goes out of scope, and the &quot;hello.txt&quot; file gets closed
}

</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<p>(You are encouraged to test the previous example under different failure
conditions: <code>hello.txt</code> doesn't exist, or <code>hello.txt</code> is not readable,
etc.)</p>
<h1><a class="header" href="#create" id="create"><code>create</code></a></h1>
<p>The <code>create</code> static method opens a file in write-only mode. If the file
already existed, the old content is destroyed. Otherwise, a new file is
created.</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;'static str =
&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::error::Error;
use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/lorem_ipsum.txt&quot;);
    let display = path.display();

    // Open a file in write-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {}&quot;,
                           display,
                           why.description()),
        Ok(file) =&gt; file,
    };

    // Write the `LOREM_IPSUM` string to `file`, returns `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; {
            panic!(&quot;couldn't write to {}: {}&quot;, display,
                                               why.description())
        },
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ mkdir out
$ rustc create.rs &amp;&amp; ./create
successfully wrote to out/lorem_ipsum.txt
$ cat out/lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>(As in the previous example, you are encouraged to test this example under
failure conditions.)</p>
<p>There is also a more generic <code>open_mode</code> method that can open files in other
modes like: read+write, append, etc.</p>
<h1><a class="header" href="#read-lines" id="read-lines">Read Lines</a></h1>
<p>The method <code>lines()</code> returns an iterator over the lines
of a file.</p>
<p><code>File::open</code> expects a generic, <code>AsRef&lt;Path&gt;</code>.  That's what
<code>read_lines()</code> expects as input.</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // File hosts must exist in current path before this produces output
    if let Ok(lines) = read_lines(&quot;./hosts&quot;) {
        // Consumes the iterator, returns an (Optional) String
        for line in lines {
            if let Ok(ip) = line {
                println!(&quot;{}&quot;, ip);
            }      
        }   
    }
}

// The output is wrapped in a Result to allow matching on errors
// Returns an Iterator to the Reader of the lines of the file.
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre></pre>
<p>Running this program simply prints the lines individually.</p>
<pre><code class="language-bash">$ echo -e &quot;127.0.0.1\n192.168.0.1\n&quot; &gt; hosts
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p>This process is more efficient than creating a <code>String</code> in memory
especially working with larger files.</p>
<h1><a class="header" href="#child-processes" id="child-processes">Child processes</a></h1>
<p>The <code>process::Output</code> struct represents the output of a finished child process,
and the <code>process::Command</code> struct is a process builder.</p>
<pre><code class="language-rust editable ignore">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }
}
</code></pre>
<p>(You are encouraged to try the previous example with an incorrect flag passed
to <code>rustc</code>)</p>
<h1><a class="header" href="#pipes" id="pipes">Pipes</a></h1>
<p>The <code>std::Child</code> struct represents a running child process, and exposes the
<code>stdin</code>, <code>stdout</code> and <code>stderr</code> handles for interaction with the underlying
process via pipes.</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // Spawn the `wc` command
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why.description()),
        Ok(process) =&gt; process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option&lt;ChildStdin&gt;`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;,
                           why.description()),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option&lt;ChildStdout&gt;` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;,
                           why.description()),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre>
<h1><a class="header" href="#wait" id="wait">Wait</a></h1>
<p>If you'd like to wait for a <code>process::Child</code> to finish, you must call
<code>Child::wait</code>, which will return a <code>process::ExitStatus</code>.</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
reached end of main
# `wait` keeps running for 5 seconds
# `sleep 5` command ends, and then our `wait` program finishes
</code></pre>
<h1><a class="header" href="#filesystem-operations" id="filesystem-operations">Filesystem Operations</a></h1>
<p>The <code>std::io::fs</code> module contains several functions that deal with the
filesystem.</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// A simple implementation of `% cat path`
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// A simple implementation of `% echo s &gt; path`
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// A simple implementation of `% touch path` (ignores existing files)
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // Create a directory, returns `io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // The previous match can be simplified using the `unwrap_or_else` method
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // Recursively create a directory, returns `io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // Create a symbolic link, returns `io::Result&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // Read the contents of a directory, returns `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // Remove a file, returns `io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // Remove an empty directory, returns `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}

</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>And the final state of the <code>a</code> directory is:</p>
<pre><code class="language-text">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>An alternative way to define the function <code>cat</code> is with <code>?</code> notation:</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<h3><a class="header" href="#see-also-17" id="see-also-17">See also:</a></h3>
<p><a href="std_misc/attribute/cfg.html"><code>cfg!</code></a></p>
<h1><a class="header" href="#program-arguments" id="program-arguments">Program arguments</a></h1>
<h2><a class="header" href="#standard-library" id="standard-library">Standard Library</a></h2>
<p>The command line arguments can be accessed using <code>std::env::args</code>, which
returns an iterator that yields a <code>String</code> for each argument:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // The first argument is the path that was used to call the program.
    println!(&quot;My path is {}.&quot;, args[0]);

    // The rest of the arguments are the passed command line parameters.
    // Call the program like this:
    //   $ ./args arg1 arg2
    println!(&quot;I got {:?} arguments: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-bash">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2><a class="header" href="#crates" id="crates">Crates</a></h2>
<p>Alternatively, there are numerous crates that can provide extra functionality
when creating command-line applications. The <a href="https://rust-lang-nursery.github.io/rust-cookbook/app.html#ex-clap-basic">Rust Cookbook</a> exhibits best
practices on how to use one of the more popular command line argument crates,
<code>clap</code>.</p>
<h1><a class="header" href="#argument-parsing" id="argument-parsing">Argument parsing</a></h1>
<p>Matching can be used to parse simple arguments:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // no arguments passed
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // one argument passed
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // one command and one argument passed
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // parse the number
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    eprintln!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // parse the command
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    eprintln!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // all the other cases
        _ =&gt; {
            // show a help message
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<h1><a class="header" href="#foreign-function-interface" id="foreign-function-interface">Foreign Function Interface</a></h1>
<p>Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign
functions must be declared inside an <code>extern</code> block annotated with a <code>#[link]</code>
attribute containing the name of the foreign library.</p>
<pre><code class="language-rust ignore">use std::fmt;

// this extern block links to the libm library
#[link(name = &quot;m&quot;)]
extern {
    // this is a foreign function
    // that computes the square root of a single precision complex number
    fn csqrtf(z: Complex) -&gt; Complex;

    fn ccosf(z: Complex) -&gt; Complex;
}

// Since calling foreign functions is considered unsafe,
// it's common to write safe wrappers around them.
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // calling a foreign function is an unsafe operation
    let z_sqrt = unsafe { csqrtf(z) };

    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);

    // calling safe API wrapped around unsafe operation
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// Minimal implementation of single precision complex numbers
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<h1><a class="header" href="#Тестирование-1" id="Тестирование-1">Тестирование</a></h1>
<p>Rust - это язык программирования, который очень заботится о корректности и
включает в себя поддержку написания тестов программного обеспечения в самом языке.</p>
<p>Тестирование поставляется в трех стилях:</p>
<ul>
<li><a href="testing/unit_testing.html">Модульное</a> тестирование.</li>
<li><a href="testing/doc_testing.html">Тестирование кода из примеров документации</a>.</li>
<li><a href="testing/integration_testing.html">Интеграционное тестирование</a>.</li>
</ul>
<p>Также Rust поддерживает указание дополнительных зависимостей для тестов:</p>
<ul>
<li><a href="testing/dev_dependencies.html">Dev-dependencies</a></li>
</ul>
<h2><a class="header" href="#Смотрите-также-49" id="Смотрите-также-49">Смотрите также:</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">Глава о тестировании</a> </li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">Описание API</a> для тестирования примеров из документации.</li>
</ul>
<h1><a class="header" href="#unit-testing" id="unit-testing">Unit testing</a></h1>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform some setup,
run the code we want to test, then assert whether the results are what we
expect.</p>
<p>Most unit tests go into a <code>tests</code> <a href="testing/mod.html">mod</a> with the <code>#[cfg(test)]</code> <a href="testing/attribute.html">attribute</a>.
Test functions are marked with the <code>#[test]</code> attribute.</p>
<p>Tests fail when something in the test function <a href="testing/std/panic.html">panics</a>. There are some
helper <a href="testing/macros.html">macros</a>:</p>
<ul>
<li><code>assert!(expression)</code> - panics if expression evaluates to <code>false</code>.</li>
<li><code>assert_eq!(left, right)</code> and <code>assert_ne!(left, right)</code> - testing left and
right expressions for equality and inequality respectively.</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// This is a really bad adding function, its purpose is to fail in this
// example.
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // This assert would fire and test will fail.
        // Please note, that private functions can be tested too!
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>.</p>
<pre><code class="language-bash">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#testing-panics" id="testing-panics">Testing panics</a></h2>
<p>To check functions that should panic under certain circumstances, use attribute
<code>#[should_panic]</code>. This attribute accepts optional parameter <code>expected = </code> with
the text of the panic message. If your function can panic in multiple ways, it helps
make sure your test is testing the correct panic.</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    } else if a &lt; b {
        panic!(&quot;Divide result is zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre>
<p>Running these tests gives us:</p>
<pre><code class="language-bash">$ cargo test

running 3 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#running-specific-tests" id="running-specific-tests">Running specific tests</a></h2>
<p>To run specific tests one may specify the test name to <code>cargo test</code> command.</p>
<pre><code class="language-bash">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>To run multiple tests one may specify part of a test name that matches all the
tests that should be run.</p>
<pre><code class="language-bash">$ cargo test panic
running 2 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#ignoring-tests" id="ignoring-tests">Ignoring tests</a></h2>
<p>Tests can be marked with the<code>#[ignore]</code> attribute to exclude some tests. Or to run
them with command <code>cargo test -- --ignored</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
#}</code></pre></pre>
<pre><code class="language-bash">$ cargo test
running 1 test
test tests::ignored_test ... ignored

test result: ok. 0 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h1><a class="header" href="#documentation-testing" id="documentation-testing">Documentation testing</a></h1>
<p>The primary way of documenting a Rust project is through annotating the source
code. Documentation comments are written in <a href="https://daringfireball.net/projects/markdown/">markdown</a> and support code
blocks in them. Rust takes care about correctness, so these code blocks are
compiled and used as tests.</p>
<pre><code class="language-rust ignore">/// First line is a short summary describing function.
///
/// The next lines present detailed documentation. Code blocks start with
/// triple backquotes and have implicit `fn main()` inside
/// and `extern crate &lt;cratename&gt;`. Assume we're testing `doccomments` crate:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// Usually doc comments may include sections &quot;Examples&quot;, &quot;Panics&quot; and &quot;Failures&quot;.
///
/// The next function divides two numbers.
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>:</p>
<pre><code class="language-bash">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#motivation-behind-documentation-tests" id="motivation-behind-documentation-tests">Motivation behind documentation tests</a></h2>
<p>The main purpose of documentation tests is to serve as an examples that exercise
the functionality, which is one of the most important
<a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">guidelines</a>. It allows using examples from docs as
complete code snippets. But using <code>?</code> makes compilation fail since <code>main</code>
returns <code>unit</code>. The ability to hide some source lines from documentation comes
to the rescue: one may write <code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code>, hide it and
<code>unwrap</code> it in hidden <code>main</code>. Sounds complicated? Here's an example:</p>
<pre><code class="language-rust ignore">/// Using hidden `try_main` in doc tests.
///
/// ```
/// # // hidden lines start with `#` symbol, but they're still compileable!
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // line that wraps the body shown in doc
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { // starting main that'll unwrap()
/// #    try_main().unwrap(); // calling try_main and unwrapping
/// #                         // so that test will panic in case of error
/// # }
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<h2><a class="header" href="#see-also-18" id="see-also-18">See Also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a> on documentation style</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on documentation guidelines</li>
</ul>
<h1><a class="header" href="#integration-testing" id="integration-testing">Integration testing</a></h1>
<p><a href="testing/testing/unit_testing.html">Unit tests</a> are testing one module in isolation at a time: they're small
and can test private code. Integration tests are external to your crate and use
only its public interface in the same way any other code would. Their purpose is
to test that many parts of your library work correctly together.</p>
<p>Cargo looks for integration tests in <code>tests</code> directory next to <code>src</code>.</p>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// Assume that crate is called adder, will have to extern it in integration test.
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code>:</p>
<pre><code class="language-rust ignore">// extern crate we're testing, same as any other code would do.
extern crate adder;

#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Running tests with <code>cargo test</code> command:</p>
<pre><code class="language-bash">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Each Rust source file in <code>tests</code> directory is compiled as a separate crate. One
way of sharing some code between integration tests is making module with public
functions, importing and using it within tests.</p>
<p>File <code>tests/common.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // some setup code, like creating required files/directories, starting
    // servers, etc.
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code></p>
<pre><code class="language-rust ignore">// extern crate we're testing, same as any other code will do.
extern crate adder;

// importing common module.
mod common;

#[test]
fn test_add() {
    // using common code.
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Modules with common code follow the ordinary <a href="testing/mod.html">modules</a> rules, so it's ok to
create common module as <code>tests/common/mod.rs</code>.</p>
<h1><a class="header" href="#development-dependencies" id="development-dependencies">Development dependencies</a></h1>
<p>Sometimes there is a need to have a dependencies for tests (examples,
benchmarks) only. Such dependencies are added to <code>Cargo.toml</code> in
<code>[dev-dependencies]</code> section. These dependencies are not propagated to other
packages which depend on this package.</p>
<p>One such example is using a crate that extends standard <code>assert!</code> macros.<br />
File <code>Cargo.toml</code>:</p>
<pre><code class="language-ignore"># standard crate data is left out
[dev-dependencies]
pretty_assertions = &quot;0.4.0&quot;
</code></pre>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// externing crate for test-only use
#[cfg(test)]
#[macro_use]
extern crate pretty_assertions;

pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre>
<h2><a class="header" href="#see-also-19" id="see-also-19">See Also</a></h2>
<p><a href="http://doc.crates.io/specifying-dependencies.html">Cargo</a> docs on specifying dependencies.</p>
<h1><a class="header" href="#unsafe-operations" id="unsafe-operations">Unsafe Operations</a></h1>
<p>As an introduction to this section, to borrow from <a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html">the official docs</a>,
&quot;one should try to minimize the amount of unsafe code in a code base.&quot; With that
in mind, let's get started! Unsafe blocks in Rust are used to bypass protections
put in place by the compiler; specifically, there are four primary things that
unsafe blocks are used for:</p>
<ul>
<li>dereferencing raw pointers</li>
<li>calling a function over FFI (but this is covered in <a href="std_misc/ffi.html">a previous
chapter</a> of the book)</li>
<li>calling functions which are <code>unsafe</code></li>
<li>inline assembly</li>
</ul>
<h3><a class="header" href="#raw-pointers" id="raw-pointers">Raw Pointers</a></h3>
<p>Raw pointers <code>*</code> and references <code>&amp;T</code> function similarly, but references are
always safe because they are guaranteed to point to valid data due to the
borrow checker. Dereferencing a raw pointer can only be done through an unsafe
block.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<h3><a class="header" href="#calling-unsafe-functions" id="calling-unsafe-functions">Calling Unsafe Functions</a></h3>
<p>Some functions can be declared as <code>unsafe</code>, meaning it is the programmer's
responsibility to ensure correctness instead of the compiler's. One example
of this is <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a> which will create a slice given a
pointer to the first element and a length.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);
        
        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre></pre>
<p>For <code>slice::from_raw_parts</code>, one of the assumptions which <em>must</em> be upheld is 
that the pointer passed in points to valid memory and that the memory pointed to
is of the correct type. If these invariants aren't upheld then the program's 
behaviour is undefined and there is no knowing what will happen.</p>
<h1><a class="header" href="#Совместимость" id="Совместимость">Совместимость</a></h1>
<p>Rust быстро развивается и из-за этого могут возникнуть определённые проблемы совместимости, не смотря на усилия по обеспечению обратной совместимости везде, где это возможно.</p>
<ul>
<li><a href="compatibility/raw_identifiers.html">Сырые идентификаторы</a></li>
</ul>
<h1><a class="header" href="#raw-identifiers" id="raw-identifiers">Raw identifiers</a></h1>
<p>В Rust, как и во многих других языках программирования, существует концепция &quot;ключевых слов&quot;.
Эти идентификаторы что-то значат для языка и из-за этого вы не можете использовать их в качестве названия переменных, именах функций и других местах.
Сырые идентификаторы позволяют использовать ключевые слова там, где они обычно не разрешены.
Это особенно полезно, когда Rust вводит новые ключевые слова и библиотеки, использующие старую редакцию Rust, имеют переменные или функции с таким же именем, как и ключевое слово, введённое в новой редакции.</p>
<p>Например, рассмотрим крейт <code>foo</code>, скомпилированный с 2015 редакцией Rust, и который экспортирует функцию с именем <code>try</code>. Это ключевое слово зарезервировано для новой функциональности в 2018 редакции, из-за чего без сырых идентификаторов мы не можем назвать так функцию.</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}
</code></pre>
<p>Вы получите ошибку:</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>Вы можете записать это при помощи сырого идентификатора:</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}
</code></pre>
<h1><a class="header" href="#meta" id="meta">Meta</a></h1>
<p>Некоторые темы не совсем соответствуют тому, как вы программируете, но предоставляют вам инструменты или инфраструктуру, которые делают лучше для всех. Эти темы включают:</p>
<ul>
<li>Документацию: генерирование пользовательской документации с использованием <code>rustdoc</code>.</li>
<li>Тестирование: создание набора тестов для библиотек, чтобы быть уверенным, что ваша библиотека делает то, что должна.</li>
<li>Бенчмаркинг: создание бенчмарков функциональности для уверенности, что она работает быстро.</li>
</ul>
<h1><a class="header" href="#documentation" id="documentation">Documentation</a></h1>
<p>Doc comments are very useful for big projects that require documentation. When
running <a href="https://doc.rust-lang.org/book/documentation.html">Rustdoc</a>, these are the comments that get compiled into
documentation. They are denoted by a <code>///</code>, and support <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#![crate_name = &quot;doc&quot;]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Example
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to Rustdoc, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    pub fn hello(&amp; self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre></pre>
<p>To run the tests, first build the code as a library, then tell rustdoc where
to find the library so it can link it into each doctest program:</p>
<pre><code class="language-bash">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<p>(When you run <code>cargo test</code> on a library crate, Cargo will automatically
generate and run the correct rustc and rustdoc commands.)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-142155799-3', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
