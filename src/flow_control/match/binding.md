# Связывание

Косвенный доступ к переменной делает невозможным ветвление и использование
переменной без повторной привязки. `match` предоставляет символ `@`
для привязки значения к имени:

```rust,editable
// Функция `age`, возвращающая `u32`.
fn age() -> u32 {
    15
}

fn main() {
    println!("Скажи мне свой возраст");

    match age() {
        0             => println!("Я ещё не родился"),
        // Можно было бы использовать только 1 ... 12 в `match`,
        // но какого возраста тогда был бы ребёнок? Вместо этого мы
        // привязываем `n` к последовательности 1 .. 12. 
        // Теперь мы можем сообщить возраст.
        n @ 1  ..= 12 => println!("Я ребёнок. Мне {:?}", n),
        n @ 13 ..= 19 => println!("Я подросток. Мне {:?}", n),
        // Ничего не привязываем.
        n             => println!("Я взрослый. Мне {:?}", n),
    }
}
```

Вы также можете использовать привязку для "деструктурирования" 
вариантов `enum`, таких как `Option`:

```rust,editable
fn some_number() -> Option<u32> {
    Some(42)
}

fn main() {
    match some_number() {
        // Вариант `Some`, выбираем, если его значение, привязанное к `n`,
        // равно 42.
        Some(n @ 42) => println!("Ответ: {}!", n),
        // При других числах.
        Some(n)      => println!("Не интересно... {}", n),
        // Для всего остального (вариант `None`).
        _            => (),
    }
}
```

### Смотрите также:

[Функции](../../fn.md), [`enum`](../../custom_types/enum.md) и [`Option`](../../std/option.md)
