При работе с обобщениями параметры типа часто должны использовать типажи 
в качестве *ограничений*, чтобы определить какие функциональные возможности
реализует тип. Например, в следующем примере для печати используется 
типаж `Display` и поэтому требуется `T` ограничить по `Display`.
Это значит что `T` *должен* реализовать `Display`.

```rust
// Определим функцию `printer`, которая принимает общий тип `T`,
// который должен реализовать типаж `Display`
fn printer<T: Display>(t: T) {
    println!("{}", t);
}
```

Ограничение ограничивает обобщенные типы, соотвествующие ограничениям. То есть:

```rust
struct S<T: Display>(T);

// Ошибка! `Vec<T>` не реализует `Display`. Эта
// специализация не удастся
let s = S(vec![1]);
```

Другой эффект ограничения заключается в том, что обобщенные экземпляры
имеют доступ к [`методам`][methods] типажей, указанных в ограничениях. Например:

{bounds.play}

Дополнительно приведём пример, [`где`][where] для большей выразительности 
также могут использоваться ограничения.

### Смотрите также:

[`std::fmt`][fmt], [`структуры`][structs], и [`типажи`][traits]

[fmt]: ../hello/print.html
[methods]: ../fn/methods.html
[structs]: ../custom_types/structs.html
[traits]: ../trait.html
[where]: ../generics/where.html
