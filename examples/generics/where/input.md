Ограничение типажа также может быть выражено с помощью утверждения `where`
непосредственно перед открытием `{`, а не при первом упоминании типа.
Кроме того, утверждения `where` могут применять ограничения типажей к 
произвольным типам, а не только к параметрам типа.

В некоторых случаях утверждение `where` является полезным:

* При указании обобщённых типов и ограничений типажей отдельно,
код становится более ясным:

```rust
impl <A: TraitB + TraitC, D: TraitE + TraitF> MyTrait<A, D> for YourType {}

// Выражение ограничений типажей через утверждение `where`
impl <A, D> MyTrait<A, D> for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
```

* Использование утверждения `where` более выразительно, чем использование
обычного синтаксиса. В этом примере `impl` не может быть непосредственно
выражен без утверждения `where`:

{where.play}

### Смотрите также:

[RFC][where], [`структуры`][struct], и [`типажи`][trait]

[struct]: ../custom_types/structs.html
[trait]: ../trait.html
[where]: https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md
