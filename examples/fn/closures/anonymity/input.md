Замыкания временно захватывают переменные из окружающих областей видимости.
Имеет ли это какие-либо последствия? Конечно. Посмотрите, как использование
замыкания в аргументах функции требует [обобщенных типов][generics], которые
необходимы из-за особенностей их определения:

```rust
// `F` должен быть обобщенным типом.
fn apply<F>(f: F) where
    F: FnOnce() {
    f();
}
```

Когда определено замыкание, компилятор неявно создает новую анонимную структуру
для хранения захваченных переменных, тем временем реализуя функциональность с
помощью одного из типажей: `Fn`, `FnMut`, или `FnOnce` для неизвестного типа.
Этот тип назначается переменной, которая хранится до самого вызова замыкания.

Так как этот новый тип заранее неизвестен, любое его использование в функции
потребует обобщенных типов. Тем не менее неограниченный параметр типа `<T>`
по прежнему будет неоднозначным и недопустим. Таким образом, ограничение по
одному из типажей: `Fn`, `FnMut`, или `FnOnce` (которые он реализует)
достаточно, чтобы указать его тип.

{anonymity.play}

### Смотрите также:

[Тщательный анализ][thorough_analysis], [`Fn`][fn], [`FnMut`][fn_mut],
and [`FnOnce`][fn_once]

[generics]: ../../generics.html
[fn]: http://doc.rust-lang.org/std/ops/trait.Fn.html
[fn_mut]: http://doc.rust-lang.org/std/ops/trait.FnMut.html
[fn_once]: http://doc.rust-lang.org/std/ops/trait.FnOnce.html
[thorough_analysis]: http://huonw.github.io/blog/2015/05/finding-closure-in-rust/
